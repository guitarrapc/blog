---
Title: Pulumi DockerBuildを使ったマルチプラットフォームDocker Image作成
Category:
- Pulumi
Date: 2025-03-06T03:22:35+09:00
URL: https://tech.guitarrapc.com/entry/2025/03/04/235900
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/6802418398333896974
---

Pulumiでマルチプラットフォーム対応のDocker Imageを作成する時は[docker-build](https://www.pulumi.com/registry/packages/docker-build/)パッケージを使うのがオススメデス。1年余りプレビュー状態ですが、これまでの[docker](https://www.pulumi.com/registry/packages/docker/)パッケージから見ると挙動に注意が必要です。

今回はPulumiでマルチプラットフォームなDocker Imageを作成する方法を紹介します。
。
[:contents]

# PulumiでマルチプラットフォームDocker Imageを作成したい

Docker Imageを作成するにあたって長年課題だったのが、マルチプラットフォームなDocker Image作成APIの不在でした。現在はDocker BuildKitをベースにマルチプラットフォームイメージを簡単に扱えるようになりましたが、PulumiのDockerイメージ作成は[長年ツギハギ対応](https://github.com/pulumi/pulumi/discussions/7428)で使いたいものではありませんでした。しかし、Docker Build Providerの[登場](https://www.pulumi.com/blog/docker-build/)でマルチプラットフォームイメージを安定して作成できるようになっています。

Pulumiを使ったDockerイメージ構成を軽くイメージしてみましょう。例えばAWSを使っているならECRにイメージをプッシュすることで、AWS IAMサービス認証でプライベートなイメージを取得できます。この挙動はサービスの安定的なコンテナイメージ取得において欠かせないもので、AzureやGoogle Cloudも同様の仕組みがあります。

PulumiでアプリケーションのイメージからECSでのタスク実行までやろうと思った場合、amd64(x86_64)向けやarm64など単独プラットフォームなイメージであっても、マルチプラットフォームなイメージでも流れは同じです。

1. ローカル・CIでイメージをビルド&ECRにプッシュ
2. TaskDefinitionでプッシュしたECRイメージを参照
3. ECS Serviceで更新したTask Definitionを用いる

マルチプラットフォームの需要がどこにあるかというと**ECS**がポイントです。2024年12月にFargateがARM64 Spotに対応したこともあり、ECSをamd64で動かしていたがarm64にしたい。あるいは両アーキテクチャで動かしたい、というケースが現実を帯びるようになりました。マルチプラットフォームなイメージに対応しておくことで、Task Definitionのイメージタグ構成はかえずに、ECS Service Providerをamd64/arm64で調整しながら実ワークロードでスムーズなアーキテクチャ変更ができます。

# マルチプラットフォームとは

マルチプラットフォームなイメージ作成については、Dockerが出している[Multi-platform builds](https://docs.docker.com/build/building/multi-platform/)が基礎として十分まとまっているので詳細はこちらに譲ります。マルチプラットフォームイメージを作るに当たって概要だけかいつまみましょう。

**単独プラットフォームイメージ**

単独のマニフェストを持ち、それがコンフィグとレイヤーセットへのポインターとなります。いわゆるDockerマニフェストという理解そのままですね。
単独のマニフェストはイメージのアーキテクチャやOSを差し、このやり方で複数アーキテクチャに提供する場合、アーキテクチャに合わせたイメージやタグを指定しないと行けません。

このやり方でamd64とarm64の両方をサポートするイメージを作るには「2つのイメージ」か「それぞれのタグ」を用意する必要があり、開発者・利用者共に使い分けが生じて面倒です。

> ![image](https://github.com/user-attachments/assets/68a0f8fc-a673-44ac-8766-02920d9bd5e3)
> 引用: https://docs.docker.com/build/building/multi-platform/

**マルチプラットフォームイメージ**

マニフェストリストと複数のマニフェストを持ちます。マニフェストリストはOS・アーキテクチャに合わせて適切なマニフェストを指し示す役割を持っています。
マルチプラットフォームイメージをレジストリからダウンロードすると、まずマニフェストリストをダウンロードし適切なアーキテクチャのイメージを選択、続いて対象のマニフェストを取得します。

このやり方でamd64とarm64の両方をサポートするイメージを作るには「単独のイメージ・タグ」があればよく、開発者は「アーキテクチャごとにイメージビルド」「マニフェストリストを作成」し、利用者はamd64・arm64に関わらず同じイメージタグを利用できます。

> ![image](https://github.com/user-attachments/assets/7e4e7587-9508-4904-bdb9-f2c984432834)
> 引用: https://docs.docker.com/build/building/multi-platform/

まとめると次のようになります。

| 対象 | 単独プラットフォームイメージ | マルチプラットフォームイメージ |
| --- | --- |
| 単独アーキテクチャ (開発者) | ◎ (簡単) | 〇[^1] |
| 単独アーキテクチャ (利用者) | ◎ | ◎ |
| 複数アーキテクチャサポート (開発者) | ×[^2] | 〇 |
| 複数アーキテクチャサポート (利用者) | ×[^3] | ◎ (簡単) |

複数アーキテクチャを単一イメージでシームレスに使ってほしい、という動機があるならマルチプラットフォームイメージ一択ですね。

# PulumiでDockerイメージを作る

ECRにDockerイメージをプッシュする流れで見てみましょう。順を追ってみてみます。

1. 単独プラットフォームイメージを作る (Pulumi.Docker)
2. 単独プラットフォームイメージを作る (Pulumi.DockerImage)
3. マルチプラットフォームイメージを作る (Pulumi.DockerBuild)

雑にマルチプラットフォームに対応しているイメージでDockefileを用意しておきます。

```
FROM alpine:latest
```

## 単独プラットフォームイメージを作る (Pulumi.Docker)

[Pulumi.Docker](https://www.pulumi.com/registry/packages/docker/)パッケージで、単独プラットフォームイメージを作ってみましょう。パッケージはこれで。

```sh
dotnet add package Pulumi.Docker --version 4.5.5
```

Pulumi C#で、ECR作成&Dockerイメージを作成しつつプッシュします。

```cs
var ecr = new Pulumi.Aws.Ecr.Repository("demo-image", new ()
{
    Name = "demo-image",
    ForceDelete = true,
}, new CustomResourceOptions());
var credential = ecr.RegistryId.Apply(x => Pulumi.Aws.Ecr.GetAuthorizationToken.InvokeAsync(new()
{
   RegistryId = x,
}));
var demoImage = new Pulumi.Docker.Image("demo-image", new()
{
    Build = new Pulumi.Docker.Inputs.DockerBuildArgs()
    {
        Context = ".",
        Dockerfile = "docker/Dockerfile",
        Platform = "linux/amd64",
    },
    ImageName = ecr.RepositoryUrl.Apply(x => $"{x}:tag1"),
    Registry = new Pulumi.Docker.Inputs.RegistryArgs
    {
        Server = ecr.RepositoryUrl,
        Username = credential.Apply(x => x.UserName),
        Password = credential.Apply(x => x.Password),
    },
    SkipPush = false,
});
```

適用してみましょう。

```
$ pulumi up

 +   ├─ aws:ecr:Repository                   demo-image                                create
 +   └─ docker:index:Image                   demo-image                                create

Resources:
    + 2 created
```

できていますね。

![image](https://github.com/user-attachments/assets/011dcb65-6e69-4b0f-aef9-e8215f70c9c2)

APIを見てわかる通り、`Pulumi.Docker.Image`は単独プラットフォームイメージのみサポートしています。マルチプラットフォームイメージ対応するために新設されたのが、`Pulumi.DockerBuild`です。

## 単独プラットフォームイメージを作る (Pulumi.DockerImage)

[Pulumi.DockerBuild](https://www.pulumi.com/registry/packages/docker-build/api-docs/image/)パッケージで、単独プラットフォームイメージを作ってみましょう。先ほどのECRを一度消してゼロベースで使う例です。[^4]

パッケージはこれで。

```sh
dotnet add package Pulumi.DockerImage --version 0.0.9
```

Pulumi.DockerとはAPIが異なっていますが、おおむね同じです。ただし、`Push`の挙動が決定的に異なっています。

```cs
var ecr = new Pulumi.Aws.Ecr.Repository("demo-image", new()
{
    Name = "demo-image",
    ForceDelete = true,
}, new CustomResourceOptions());
var credential = ecr.RegistryId.Apply(x => Pulumi.Aws.Ecr.GetAuthorizationToken.InvokeAsync(new()
{
    RegistryId = x,
}));
var demoImage = new Pulumi.DockerBuild.Image("demo-image", new()
{
    BuildOnPreview = true,
    Context = new Pulumi.DockerBuild.Inputs.BuildContextArgs
    {
        Location = "docker/"
    },
    Platforms = [Pulumi.DockerBuild.Platform.Linux_amd64],
    Tags = [
        ecr.RepositoryUrl.Apply(x => $"{x}:tag1"),
    ],
    Registries = new Pulumi.DockerBuild.Inputs.RegistryArgs
    {
        Address = ecr.RepositoryUrl,
        Username = credential.Apply(x => x.UserName),
        Password = credential.Apply(x => x.Password),
    },
    Push = !Pulumi.Deployment.Instance.IsDryRun, // previewとpushでboolが切り替わる
});
```

適用してみましょう。

```
$ pulumi up

 +   ├─ aws:ecr:Repository                   demo-image                                created (0.55s)
 +   └─ docker-build:index:Image             demo-image                                created (5s)

Resources:
    + 2 created
```

できていますね。

![image](https://github.com/user-attachments/assets/42084abe-e87b-4247-a3f7-6864ab2024ae)

**DockerBuildの注意点**

`Push = true`にしていると、ECRリポジトリがない状態で`pulumi up`するとエラーになります。Docker.Buildでは平気だったのに!!

```
  docker-build:index:Image (demo-image):
    error: docker-build:index:Image resource 'demo-image': property exports[0] value {<nil>} has a problem: at least one tag or export name is needed when pushing to a registry
```

代わりに`Pulumi.Deployment.Instance.IsDryRun`を使ってpreview時はプッシュしないように制御しましょう。

## マルチプラットフォームイメージを作る (Pulumi.DockerBuild)

APIを見てわかる通り、Pulumi.DockerBuild.Imageはマルチプラットフォームイメージのみサポートしています。先ほどのプラットフォームにarm64を追加しましょう。

```cs
    var demoImage = new Pulumi.DockerBuild.Image("demo-image", new()
    {
        BuildOnPreview = true,
        Context = new Pulumi.DockerBuild.Inputs.BuildContextArgs
        {
            Location = "docker/"
        },
        Platforms = [Pulumi.DockerBuild.Platform.Linux_amd64, Pulumi.DockerBuild.Platform.Linux_arm64],
        Tags = [
            ecr.RepositoryUrl.Apply(x => $"{x}:tag1"),
        ],
        Registries = new Pulumi.DockerBuild.Inputs.RegistryArgs
        {
            Address = ecr.RepositoryUrl,
            Username = credential.Apply(x => x.UserName),
            Password = credential.Apply(x => x.Password),
        },
        Push = !Pulumi.Deployment.Instance.IsDryRun,
    });
```

適用してみましょう。

```
$ pulumi up

 ~   └─ docker-build:index:Image             demo-image                                updated (5s)     [diff: ~platfor

Resources:
    ~ 1 updated
```

できていますね。先ほどまではArtifact typeがImageでしたが、Image Indexに変わったことがわかります。

![image](https://github.com/user-attachments/assets/8963b2d6-167f-46f6-a3c0-30511f104d32)

# まとめ

これでマルチプラットフォームなアプリケーションイメージを作るのもイメージできそうですね!

アプリケーションはPulumiとは独立してイメージビルド・プッシュすることが多いのですが、中には簡易なアプリケーション構成なためIaCでデプロイまでまとめてやって手間を極小にするケースがあります。本記事がそういったユースケースで参考になれば幸いです。

# 参考

* [Docker Provider | Pulumi](https://www.pulumi.com/registry/packages/docker/)
* [Docker Build Provider | Pulumi](https://www.pulumi.com/registry/packages/docker-build/)
* [#7428 Using multi-arch Docker images with Pulumi? | pulumi/pulumi](https://github.com/pulumi/pulumi/discussions/7428)
* [Introducing the new Docker Build provider | Pulumi Blog](https://www.pulumi.com/blog/docker-build/)

[^1]: マニフェストリストを必要とし、手間が増えている
[^2]: タグかイメージを分けざるを得ない
[^3]: タグやイメージ指定を分けざるを得ない
[^4]: ECRをかえずイメージ部分だけマイグレートもできます
