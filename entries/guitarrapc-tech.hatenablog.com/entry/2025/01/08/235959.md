---
Title: ConsoleAppFrameworkの処理実行前後に処理を挟む
Date: 2025-01-08T23:59:59+09:00
URL: https://tech.guitarrapc.com/entry/2025/01/08/235959
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/6802418398318544161
---

C#でConsoleAppFrameworkを使ってCLIを用意するとき、バッチ処理となるメソッド本体の前後で処理を挟みたいことがあります。例えば、処理の前後にログを出力したい、所要時間を計測したい、処理前に前提を満たせているかチェックしたいなどです。
今回は、ConsoleAppFramework v5のConsoleAppFilterを使って処理実行前後に処理を挟む方法を紹介します。

[:contents]

# ConsoleAppFrameworkとは

コマンドラインアプリケーションを書く時、どの言語でも事前作業が結構求められてフレームワークがほしくなります。

- サブコマンドの提供
- コマンドに引数を提供
- コマンドにオプショナル引数を提供
- 実行時の引数の解析(引数を型マッピングして処理本体に渡す)
- ヘルプの表示
- 例外終了や終了コードハンドリング
- 非同期ハンドリング

[ConsoleAppFrameworkv](https://github.com/Cysharp/ConsoleAppFramework)はC#のCLIフレームワークです。その特徴はC#のクラス・メソッド・コメント・属性をうまく連動させており、メソッドを用意すればCLIコマンドを提供できるように設計されています。先ほどの一覧は次のようにカバーされています。

- 登録したクラスのpublicメソッドに`CommandAttribute`属性をつけるとメソッドそれぞれをサブコマンドとして登録
- メソッドのパラメーターをコマンド引数として提供
- メソッドのパラメーター(デフォルト値あり)をオプショナル引数として提供
- 実行時の引数をメソッドパラメーターにマッピング
- コマンドに対して`--help`を自動提供、メソッドのコメントをヘルプとして提供
- メソッド本体で例外が発生した場合、終了コードを1に設定して終了
- asyncな非同期メソッドもサポート

## ConsoleAppFrameworkの使い方

紹介した機能があればCLIは問題なくかけます。例えば`foobarというサブコマンドでnameという引数を持たせて、"Hello, {name}!"と表示させるコマンドを用意する`CLIを用意する場合、次のように書けます。

```cs
// global.cs
global using ConsoleApp1;
global using ConsoleAppFramework;
```

```cs
// Program.cs
var app = ConsoleApp.Create();
app.Add<SampleCommand>();
app.Run(args);

namespace ConsoleApp1
{
    public class SampleCommand
    {
        /// <summary>
        /// サンプルのコマンド
        /// </summary>
        /// <param name="name">必須のパラメーター、名前を指定します。</param>
        [Command("foobar")]
        public void FooBar(string name)
        {
            Console.WriteLine($"Hello {name}!");
        }
    }
}
```

launchSettings.jsonで次の定義を用意しておくとVisual Studioで簡単に実行できます。

```json
{
  "profiles": {
    "help": {
      "commandName": "Project",
      "commandLineArgs": "foobar --help"
    },
    "foo": {
      "commandName": "Project",
      "commandLineArgs": "foobar --name foo"
    }
  }
}
```

Visual Studioでhelpプロファイルを実行してみましょう。

![image](https://github.com/user-attachments/assets/4d5f4145-4ef3-425f-8bae-7dbb1b204ebb)

```sh
Usage: foobar [options...] [-h|--help] [--version]

サンプルのコマンド

Options:
  --name <string>    必須のパラメーター、名前を指定します。 (Required)

D:\github\test\ConsoleApp1\ConsoleApp1\bin\Debug\net9.0\ConsoleApp1.exe (process 35412) exited with code 0 (0x0).
To automatically close the console when debugging stops, enable Tools->Options->Debugging->Automatically close the console when debugging stops.
Press any key to close this window . . .
```

[実行例]

簡単ですね。

# コマンドの前後に処理を簡単にはさみたい

コマンドを大量に作っていくと、コマンド本体の実行前後に処理を挟む機能がほしくなります。[^2]
例えば「コマンド本体の実行時に起動ログを出力」したくなることがよくあります。

```cs
コマンドFooBarが実行されました。
// コマンド本体のログ
// ....
// ....
コマンドが完了しました。
```

次のようにメソッドの前後にログ出力をいれてもいいのですが、コマンドが増えると面倒なことこの上ありません。

```cs
public void FooBar()
{
  Console.WriteLine($"コマンド{nameof(FooBar)}が実行されました。");
  // コマンド
  // ...
  // ....
  Console.WriteLine($"コマンドが完了しました。");
}
```

## ConsoleAppFilter

ConsoleAppFramework v5には、処理を前後簡単に挟むための`ConsoleAppFilter`が導入されました。これを使うと、コマンド本体の前後に処理を挟むことができます。




[^1]: 2024年6月にv4からv5になって大幅なパフォーマンス向上とともにAPI変更があったので注意してください。
[^2]: Webサーバーでリクエストを受ける前後に処理をかぶせるミドルウェアのようなものをイメージしてください
