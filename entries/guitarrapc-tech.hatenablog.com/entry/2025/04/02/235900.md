---
Title: 2025年4月以降もGitHub ActionsでUbuntu 20.04環境を継続利用する
Category:
- CI/CD
- Ubuntu
Date: 2025-04-02T23:59:00+09:00
URL: https://tech.guitarrapc.com/entry/2025/04/02/235900
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/6802418398355446501
---

GitHub ActionsにはホストランナーとしてUbuntuがありますが、Ubuntu 20ランナーイメージは[2025/02/01-04/15まででサポート終了](https://github.blog/changelog/2025-01-15-github-actions-ubuntu-20-runner-image-brownout-dates-and-other-breaking-changes/)です。これ以降は、`ubuntu-20.04`ホストランナーを使えませんが、Ubuntu 20.04環境をCIとして利用したいケースもあります。

今回は、2025/4/16以降もUbuntu 20.04環境を使う方法を紹介します。

[:contents]

# なんでUbuntu 20.04環境を使いたいの?

Ubuntu 20.04は2025/Aptで[EOL](https://jp.ubuntu.com/blog/ubuntu-20-04-lts-end-of-life-standard-support-is-coming-to-an-end-jp)を迎えます。このため、動作環境として使うのはやめて22.04や24.04に移行できるなら移行しましょう。しかしCI環境として見るとUbuntu 20.04はまだまだメリットがあります。

例えば古いバージョンのglibcやglibc++のバージョンが安定動作するので、多くのLinux環境で動作するネイティブアプリケーションをビルドする環境にはうってつけです。どういうことかというと、glibcでビルドしたアプリケーションはビルドした環境より新しいglibc環境では互換性があるため動作すると期待できる一方、ビルドした環境より古いglibc環境ではまず動作しません。となると、ある程度安定して使える古すぎない環境のglibcを用いてビルドするのは幅広い環境で動作するアプリケーションをビルドするのにうってつけです。

glibcはLinuxディストリビューションごとにバージョンが異なるため、ビルドした環境より新しいglibc環境で動作するかは各ディストリビューションのglibcバージョンに依存します。各ディストリビューションのglibcバージョンは[次のサイト](https://repology.org/project/glibc/versions)でまとまっています。一覧から分かる通り、Ubuntu 22.04でビルドするとCentOS Stream 9で動作しないので、単純にUbuntu 22.04に移行するのでは困ると分かります。

* Ubuntu 20.04: glibc 2.31
* Ubuntu 22.04: glibc 2.35
* CentOS Stream 9: glibc 2.34
* CentOS Stream 10: glibc 2.39

[f:id:guitarrapc_tech:20250422194725p:plain:alt=Ubuntuのglibcバージョン]

[f:id:guitarrapc_tech:20250422194735p:plain:alt=CentOS Streamのglibcバージョン]

glibcのバージョンで見た時Ubuntu22.04のglibc2.35は割と新しく他のディストリビューションで動作しない可能性が高いため、Ubuntu 20.04環境は依存が解決された状態でビルドできる貴重な環境です。もちろんUbuntu 22.04でglibcのバージョンを下げることも検討できますが、glibcのバージョンを下げた時に各種ツールチェインが素直に動くかというとそうでもないので、素直にUbuntu 20.04環境を使うのはアプリケーションのビルドにおいて重要な意味があります。

# これまでのUbuntu 20.04環境の使い方

2025/4/15までは次のように`runs-on`に`ubuntu-20.04`を指定するだけで、Ubuntu 20.04環境を使うことができました。
例えばこの環境に.NET SDKとRustをインストールする場合は次のように書きます。

```yaml
name: ubuntu-20.04
on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-20.04
    timeout-minutes: 30
    steps:
      - uses: actions/setup-dotnet@67a3573c9a986a3f9c594539f4ab511d57bb3ce9 # v4.3.1
        with:
          dotnet-version: '9.0.x'
      - name: check dotnet version
        run: dotnet --list-sdks
      - uses: actions-rust-lang/setup-rust-toolchain@9399c7bb15d4c7d47b27263d024f0a4978346ba4 # v1.11.0
      - name: check rust version
        run: rustc --version
      - name: check cargo version
        run: cargo --version
```

2025/4/16以降は、`ubuntu-20.04`を指定してもUbuntu 20.04環境は使えません。

```sh
Requested labels: ubuntu-20.04
Job defined at: guitarrapc/ubuntu-glibc/.github/workflows/ubuntu20-old.yaml@refs/pull/2/merge
Waiting for a runner to pick up this job...
Job is waiting for a hosted runner to come online.
Job is completed before starting.
```

[f:id:guitarrapc_tech:20250422194748p:plain:alt=Ubuntu-20.04はもう使えない]

# 2025/4/16以降のUbuntu 20環境の使い方

GitHub ActionsでUbuntu 20.04を使う方法をいくつか考えてみましょう。この中だとBが現実的に手間が小さく、シンプル、何か変更あっても保守しやすそうです。今回はこの方法を考えます。

* A. GitHub Actionsのジョブ中でDocker ComposeなどでUbuntu 20.04コンテナを起動して実行
* B. ジョブをUbuntu 20.04コンテナで実行する
* C. 適当なUbuntu 20.04マシンを用意してセルフホストランナーで実行
* D. そのほか素晴らしいアイデア

## Ubuntuコンテナイメージを選択する

GitHub Actionsには[ジョブをコンテナで実行する方法](https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/running-jobs-in-a-container)[^1]があり、GitHub Actionsジョブをホストランナーではなく指定したコンテナで実行できます。

では、どのコンテナイメージを使うのが検討しましょう。ビルドで使うので、Gitやcurl、build-essential、ca-certificatesなどは入っていて欲しいところです。ホストランナーなら.NET SDKやRustなど各種ランタイムも入っていますが、そこはあきらめるとしてもある程度のセットアップは避けられるなら避けたいものです。ぱっと思いつくのは次のイメージです。

* A. Docker Hubの公式[Ubuntu](https://hub.docker.com/_/ubuntu/)イメージ
* B. 自分でビルドしたイメージをghcrにホストして利用
* C. 他のイメージ

AのDocker Hubの公式Ubuntuイメージには、curlを始めとして各種aptなどツールは何も入っていません。ただ、公式Ubuntuは過去のイメージを消すことはなさそうです。実際18.04イメージはまだ残っています。

BはAの発展形です。各種aptなどツールのセットアップに時間がかかるならイメージを自分でビルドしてghcrにホストしておくのが良いでしょう。ただしDockerfileを用意してイメージを作成、ghcrにホストなどメンテナンスしていく必要があります。

Cは、A/Bの手間を避けたい気持ちが強い選択です。始めから各種aptが入っている3rdパーティのUbuntuイメージがあれば手間を大きく削減出来そうです。3rdパーティということは、Ubuntu 20.04のコンテナイメージがEOLで消されてもしょうがないリスクがあります。

条件をいろいろ検討すると、Aの公式Ubuntuイメージを使ってビルドごとにツールをセットアップで始めれば良さそうです。ツールのセットアップが耐えきれないぐらいに長いなら、Bにしましょう。

方針が決まったのでワークフローを書いていきます。

## ジョブをUbuntu 20.04コンテナで実行する

GitHub Actionsのジョブを`ubuntu:20.04`コンテナで実行するには、`runs-on`に`ubuntu-24.04`[^2]を指定し`container`にUbuntu 20.04イメージを指定します。後は必要なツールをセットアップして、ビルドに望めばOKです。

```yaml
name: ubuntu-20.04
on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-24.04
    container:
      # Needs to lock glibc version to 2.31, ubuntu 20.04 has glibc 2.31
      image: ubuntu:20.04
    timeout-minutes: 30
    steps:
      - name: apt-get
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          apt-get update
          apt-get install -y unzip curl git autoconf build-essential ca-certificates tzdata
      # follow https://learn.microsoft.com/en-us/dotnet/core/install/linux-ubuntu-install?tabs=dotnet8&pivots=os-linux-ubuntu-2004#register-the-ubuntu-net-backports-package-repository
      - name: apt-get (.NET)
        run: |
          apt-get install -y libicu66
      - name: check glibc version
        run: ldd --version
      - uses: actions/setup-dotnet@67a3573c9a986a3f9c594539f4ab511d57bb3ce9 # v4.3.1
        with:
          dotnet-version: '9.0.x'
      - name: check dotnet version
        run: dotnet --list-sdks
      - uses: actions-rust-lang/setup-rust-toolchain@9399c7bb15d4c7d47b27263d024f0a4978346ba4 # v1.11.0
      - name: check rust version
        run: rustc --version
      - name: check cargo version
        run: cargo --version
```

ワークフローを実行すると.NET SDKやRustツールチェインがセットアップできているのがわかります。

[f:id:guitarrapc_tech:20250422233515p:plain:alt=ワークフローを実行するとツールチェインがセットアップできている]

# コンテナ実行ジョブの注意点

コンテナ実行ならではの注意点があります。公式ドキュメントでは記載がないので参考にどうぞ。
各セクションは次のような意味を持ちます。

* ✔️ DO: 推奨
* ⚠️ CONSIDER: 検討/考慮する
* ❌ AVOID: 避ける

## ✔️ DO: 公式のイメージセットアップを参考にする

Ubuntu 20.04など指定した環境を再現する場合、公式はどうやっているのか、どうやるのを推奨しているのか参考にするのが良いでしょう。

GitHub ActionsホストランナーOSのコンテナイメージは[actions/runner-images](https://github.com/actions/runner-images)で公開されています。また、各種言語のコンテナイメージも多くは公開されています。

* [Ubuntu 20.04](https://github.com/actions/runner-images/blob/38a05d5bbcabb6b72e141c0ecf4f1ad74318096a/images/ubuntu/Ubuntu2004-Readme.md)ホストランナーのイメージセットアップがある
* .NET SDKは[dotnet/dotnet-docker](https://github.com/dotnet/dotnet-docker)にイメージセットアップがある
* .NET SDKは[Ubuntuセットアップ](https://github.com/dotnet/docs/blob/de5fe14527001c6fae236c5a8712537abe7c3e8d/docs/core/install/linux-ubuntu-install.md)にUbuntu 20.04のセットアップがある

今回.NET SDK向けにはICUのみ設定しましたが、[公式ドキュメント](https://learn.microsoft.com/en-us/dotnet/core/install/linux-ubuntu-install?tabs=dotnet9&pivots=os-linux-ubuntu-2004#register-the-ubuntu-net-backports-package-repository)は他ツールのセットアップも推奨しています。必要に応じて追加すればいいでしょう。

- ca-certificates
- libc6
- libgcc-s1
- libgssapi-krb5-2
- libicu66
- libssl1.1
- libstdc++6
- zlib1g

## ⚠️ CONSIDER: defaults.run.working-directoryはコンテナに存在するパスか注意する

ジョブで`run`を実行する際、常に指定したパスをカレントディレクトリにして実行するのに`defaults.run.working-directory`を指定することがあります。
ホストマシンの`runs-on`の場合、ホストに存在しないパスを指定していても特にエラーが出ることはありませんでしたが、コンテナにおいてはコンテナにないパスを指定すると`OCI runtime exec failed`エラーが出ます。
なお、`nodejs`アクションのように`run:`を使っていない場合は、ホストに存在しないパスで実行されてもエラーになりません。

```yaml
jobs:
  build:
    runs-on: ubuntu-24.04
    container:
      image: ubuntu:20.04 # コンテナジョブ実行ならなんでもいい
    timeout-minutes: 30
    defaults:
      run:
        working-directory: /foo # コンテナに存在しないパスを指定するのは避ける！
    steps:
      - name: apt-get
        run: |
          echo foo
```

```sh
OCI runtime exec failed: exec failed: unable to start container process: chdir to cwd ("/foo") set in config.json failed: no such file or directory: unknown
Error: Process completed with exit code 126.
```

もしリポジトリにあるパスを指定したい場合は、`run`が実行されるステップの前に`checkout`を実行しておくとエラーが出ません。

```yaml
jobs:
  build:
    runs-on: ubuntu-24.04
    container:
      image: ubuntu:20.04
    timeout-minutes: 30
    defaults:
      run:
        working-directory: /foo # リポジトリに/fooが含まれる
    steps:
      # 先にチェックアウトする
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      - name: apt-get
        run: |
          echo foo
```


## ❌ AVOID: 大きなサイズのパッケージは利用を避ける

GitHub Actionsのコンテナ実行に限った話ではありませんが、なるべく小さいサイズのパッケージを利用するようにしましょう。
毎ビルド時にセットアップするので、パッケージサイズが大きいと失敗する確率が飛躍的に上がります。残念ながらaptはそこまで安定していませんし、.NETインストールスクリプトのホスト先も不安定です。

パッケージサイズを小さくするだけで、ビルドの安定性が上がります。

```sh
# AVOID: サイズの大きなパッケージは避ける
apt-get install -y libicu-dev

# DO: サイズの小さなパッケージを利用する
apt-get install -y libicu66
```

# まとめ

glibcのバージョンに由来してUbuntu 20.04環境を使う、そんなニッチなニーズも世の中にはあります。今回のようにGitHub Actionsは任意のコンテナイメージを利用できるので、小さな努力でやりたいことが実現できるのは素晴らしいですね。

# 参考

* [Ubuntu 20.04 LTSの提供終了 | Ubuntu](https://jp.ubuntu.com/blog/ubuntu-20-04-lts-end-of-life-standard-support-is-coming-to-an-end-jp)
* [glibc package versions | Repology](https://repology.org/project/glibc/versions)
* [GitHub Actions: Ubuntu 20 runner image brownout dates and other breaking changes | GitHub Changelog](https://github.blog/changelog/2025-01-15-github-actions-ubuntu-20-runner-image-brownout-dates-and-other-breaking-changes/)
* [The Ubuntu 20.04 Actions runner image will begin deprecation on 2025-02-01 and will be fully unsupported by 2025-04-15 · Issue #11101 | actions/runner-images](https://github.com/actions/runner-images/issues/11101)
* [Running jobs in a container | GitHub Docs](https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/running-jobs-in-a-container)

[^1]: 似た方法にサービスコンテナがありますが[サービスコンテナ](https://docs.github.com/ja/actions/using-containerized-services/about-service-containers)はジョブの実行環境を提供するものではなく、ジョブの実行環境にサービスを追加するものです。
[^2]: `ubuntu-24.04`でなくても他のイメージでもいいですが、わかりやすく現在の最新ホストランナーにします
