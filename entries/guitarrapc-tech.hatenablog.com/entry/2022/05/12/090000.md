---
Title: Infrastructure as Code に最低限求めること
Category:
- Terraform
- Pulumi
- Azure
Date: 2022-05-12T09:00:00+09:00
URL: https://tech.guitarrapc.com/entry/2022/05/12/090000
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/13574176438091291810
---

Infrastructure as Code (以降IaC) で組むときにIaCツールを選ぶ基準はいろいろあり、様々な理由で選ぶことでしょう。

* IaCの言語がチームとって扱いやすいか
* クラウドやサービスへのIaCの対応状況は早い/十分か
* コミュニティの大きさは十分でググれば情報を入手できるか
* 実装がオープンソースで公開されているか
* 利用事例が欲しいか

しかし、こういった基準よりまず「IaCというからには最低限出来ていないと困ること」というのが個人的にあります。

最近、Bicepで組んでいたAzureの環境をPulumiに移行したのですが、その理由はBicepではIaCが維持できないと判断したためでした。
IaCツールを使っていてIaCが維持できないと判断したのは初めてだったので、いい機会ですしIaCに最低限求めることを言語化してみましょう。

[:contents]

# 概要

私はIaCに、コードとリソース[^1] 状態の一致保障、実行プランが出力できること、ステート[^2] を持てることを求めます。
これらが不完全なIaCでは、コードでのリソース管理は不完全なものになり、今回のように維持できない原因になるため避けます。

* コードとリソース状態の一致を保障できることを求める。一致が保障できることで、コードからリソースの状態を完全に制御できる。(コードファースト)

<figure class="figure-image figure-image-fotolife" title="コードとリソースの状態が一致">[f:id:guitarrapc_tech:20220512040802p:plain]<figcaption>コードとリソースの状態が一致</figcaption></figure>

* 実行前に実行プランを出力できることを求める。実行プランによりコードの変更適用前にリソースへの影響がわかるため、PRベースでレビューをうけつつ開発ができる。また、正確な実行プランには、ステートかそれに準じたものと継続した開発体制が必要になるでしょう

<figure class="figure-image figure-image-fotolife" title="実行プランによるコード変更によるリソース差分の確認">[f:id:guitarrapc_tech:20220512041228p:plain]<figcaption>実行プランによるコード変更によるリソース差分の確認</figcaption></figure>

* ステートをIaCサービスやオブジェクトストレージに配置し、ステート実行時にロックできることを求める。ステートをローカル以外に持ち、実行ごとにロックがかかることで、チーム開発でブランチを同時に複数稼働させることができる

<figure class="figure-image figure-image-fotolife" title="ステートファイルはリモートに配置し実行ごとにロック">[f:id:guitarrapc_tech:20220512042217p:plain]<figcaption>ステートファイルは実行ごとにロック</figcaption></figure>

# IaC でやりたいこと

IaCでやりたいことは「**コードでクラウドリソースを管理できる**」これだけです。しかし、コードでクラウドリソースを管理できるとはどういうことでしょうか?

私は、コードで定義を書いたらリソースが追加されてほしいし、コードの定義を変更したらリソースが変更されてほしいし、コードの定義を消したらリソースが削除されてほしいです。
コードの定義 = リソースの状態と一致するとコードでクラウドリソースが管理でき、クラウドコンソールで操作する機会を大きく減らすことができます。[^3]

コードでリソースを管理するためにはチームでスムーズに開発します。
チーム各自でブランチを切って並行してコードを修正、修正ごとに実行プランで差分を確認し、レビューを受け、問題ないならマージしたいでしょう。
ステートをリモートに置いたり、実行ごとにロックされるとチーム開発で扱いやすくなります。

レビューの漏れに対応するためには、コードで誤って消されてもリソースの削除をブロックする機能も必要になるでしょう。
コードをリソースした後に、クラウド側でリソースに変更がかかったりすることがあるのを考慮すると、リソースの変更差分を無視する機能も必要になるでしょう。

# IaC に最低限求めること

IaCでやりたいことから、IaCに最低限求めることがわかります。

* コード = リソース状態になることを期待します
    * コードを追加したときに、リソースでも追加されることを期待
    * コードを変更したときに、リソースでも変更されることを期待
    * コードを削除したときに、リソースは削除されることを期待
    * コードで誤って削除がかかる変更を記述したときに、リソースの削除をブロックする記述ができることを期待(protection)
    * コードの適用時に、リソースで起こった変更を無視したりコードの変更を無視する記述ができることを期待(ignore)
* コードの適用前に、実行プランを表示して実リソースとの差分を正確に示せることを期待
    * 実行プランは、「現在のリソース状態とコードの差分」を示せることを期待(ステートとの差分では実リソースとずれることが多くある)
* ステートは、オブジェクトストレージやIaCのサービスで保持できることを期待
    * 実行ごとに透過的にロックがかかるとよいでしょう

## IaC でコードとリソースの状態一致が保証できないとどうなるのか

やりたいことや求めることは分かりましたが、それは本当に必要なのでしょうか?
IaCでコードとリソースの一致を保証できないと何が起こるのかを考えてみましょう。

題材は、冒頭にあげたAzureのBicepです。

ARM TemplateとBicepについて軽く説明しましょう。[ARM Template](https://docs.microsoft.com/ja-jp/azure/azure-resource-manager/templates/)や[Bicep](https://github.com/Azure/bicep)は、AzureにおいてIaCの位置づけにあります。BicepはARM TemplateのためのDSLという位置づけでビルドするとARM Template (JSON定義) を出力します。

Bicepでコードを記述し、Azureにデプロイしたとき次の挙動をします。

1. BicepコードをビルドしてARM Templateを出力
2. AzureにARM Templateをデプロイ
3. AzureはARM Templateに基づいてリソースの作成、既存のリソースがある場合は変更を実施
4. AzureへデプロイをCompleteモードで実施した場合は、Azureのリソースが削除対象か見て削除対象ならリソースを削除、削除対象じゃない場合はARM Templateからは消すがリソースは維持

一連の流れの中で特徴的なのが、Step3とStep4です。

**ステートを持たない**

Step3は、Bicep/ARM Templateがステートを持たないIaCであり、展開されたARM Templateに基づいてリソースを更新することを示します。
このためか、Bicepでコードとリソースの実行プランには[6つのステータス](https://docs.microsoft.com/ja-jp/azure/azure-resource-manager/bicep/deploy-what-if#change-types)があります。[^4]
ステータスで注目すべきは「デプロイという適用まで挙動が不定なケース」が含まれていることです。

> * デプロイ: リソースは存在し、Bicep ファイル内で定義されている。 リソースは再デプロイされる。 リソースのプロパティは、変更される場合と変更されない場合がある。 いずれかのプロパティが変更されるかどうか判断するのに十分な情報がない場合、操作ではこの変更の種類が返される。この状況は、ResultFormat が ResourceIdOnly に設定されている場合にのみ表示される

ARM Templateは、ステートではなく変更する予定の定義になります。定義と実リソースでも差分が取得できるか不明というのは、実行プランが信用できないということであり残念な体験です。

**コードとリソースは一致が保証されていない**

Step4は、Bicep/ARM Templateは、その定義を消してもリソースが削除される保証はないことを示します。
これは削除のステータス説明にも明記されています。

> * 削除: この変更の種類は、JSON テンプレートのデプロイに完全モードを使用する場合にのみ適用される。 リソースは存在しますが、Bicep ファイル内では定義されていません。 完全モードでは、リソースが削除される。 この変更の種類には、完全モードの削除をサポートしているリソースのみが含まれる

BicepのデプロイにはIncrementとCompleteの2モードがあります。
Incrementは増分デプロイで、Bicepコードから定義を消してもリソースは残ります。
Completeは完全デプロイで、ARM Templateとリソースの同期のため変更や削除をします。コードとリソースの一致を考えるとCompleteモード一択ですが、[コードを削除してもリソースが消えるかはリソース次第](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/deployment-complete-mode-deletion)です。

BicepでIaCを行おうとしてもコードとリソースの一致保障がなく、コードとリソースの乖離が進みます。
コードを見てもリソースの状態は保証できないため、今の状態、適用した後の状態を正確に把握するにはAzureポータルやCLIで状態を取得するしかありません。IaCとは?

残念ながら、BicepやARM TemplateはIaCに最低限求めることができず、継続的にIaCはできないと判断しPulumiに移行したのでした。
Pulumiに移行したのは、Azureのネイティブ実装がありAzureの新規API公開から最速1日で対応するなどの高速な対応とTerraformに比べた時のAzure APIの網羅性からです。

# まとめ

リソースを作る、変更する、削除するをすべてコードで行うには、[Terraform](https://www.terraform.io/)や[Pulumi](https://www.pulumi.com/)、[CDK](https://aws.amazon.com/jp/cdk/)などを採用します。いずれも、現在のリソースの状態とコードの差分を常に管理でき、正確な実行プランを持ち、ステートを安全に維持できます。

リソースを作ることに注力し、変更や削除はコンソールでいいという場合、[ARM Template](https://docs.microsoft.com/ja-jp/azure/azure-resource-manager/templates/)や[Bicep](https://github.com/Azure/bicep)が候補に入ります。しかし、作りっぱなしでメンテナンスされなくなるコードは、限定的なシーンでしか活用できない上に負債返却の機会を失うため、採用には慎重です。(再現環境を作ったりするのにはいいんですけどね！ )

IaCを選ぶ前に、それが自分の期待するIaCかは考えたい日々でした。

# おまけ

書こう書こうと思って、ずっと書いていなかったので、IaCを使うにあたっての注意をいくつかおまけにどうぞ。

## IaC やクラウドによる挙動の違い

IaC実行時の挙動は、IaCの実装やクラウド側のAPIにより異なります。同じIaCでもクラウドによって挙動が変わるのは、マルチクラウドをしたことがある人なら経験あるのではないでしょうか。

* リソースの設定がコード上でリソースのインラインで設定するのではなく別リソース定義を作る場合、コード削除時のリソース状態はIaCによって変わる。コード未設定時に値が戻らず、設定されたときに状態が残るケースも見かける。この場合、コードとリソースが不一致になるため使いにくいと感じるでしょう
* 連続でIaCを実行すると、前回の実行が残っていて後から実行してね、と言われれるIaCとクラウドの組み合わせがあったりする

## IaC とコンソールやCLIの違い

クラウドコンソールやCLIでリソースを作ると、クラウド側で設定していないことまで設定してくれます。

一方で、IaCはコードで設定したことしか設定しない (デフォルト値はある) ということ多いです。

これにより、IaCで作ったときはコンソールやCLIより手間がかかるという面もありますが、コードとリソースの状態が一致する要素になっていると感じます。


## IaC 実行はローカルかリモートか

IaCを実行したときに、ローカル実行されるか、IaCのサービスでリモート実行されるかは、 IaCや連携方法によって変わります。
例えばTerraformはTerraform Cloudを使うとリモート実行できますし、Terraform Cloudにはステートだけ保持してローカル実行をできます。



[^1]: リソース = クラウド環境における設定対象とします。
[^2]: ステート = 前回IaCを適用した状態とします。
[^3]: クラウドによる面があるのは同意するところです。AWSやGCPの場合ほぼコンソール操作がほぼなくなりますが、Azureでは何かとポータルを使う機会があります。
[^4]: 6つもある理由は不明ですが、ステートがないことに由来すると考えています。多くのIaCのステータスは4つ (create、update、delete、ignore) なのを考えると多いですね。
