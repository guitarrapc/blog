---
Title: terraform-provider-sopsとEphemeral valuesを使ってTerraformでシークレットを安全に扱う
Category:
- Terraform
- AWS
Date: 2026-01-06T23:00:00+09:00
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/17179246901342252571
PreviewURL: https://tech.guitarrapc.com/draft/entry/4CYNriI0-JaV9EDiArrHVqEKX3Q
CustomPath: 2026/01/06/230000
Draft: true
---

AWSにはSSM Parameter StoreやSecrets Managerなど、機密情報を安全に管理するためのサービスが提供されています。TerraformでAWS環境を構築するにあたり、Terraformを使っていると、これらに入れるデータもTerraformで管理したくなります。しかし、従来はGitまでは暗号化しても、TerraformのStateファイルに平文で機密情報が保存されてしまう問題がありました。

2025年にリリースされたTerraform 1.10.0で[Ephemeral resource](https://developer.hashicorp.com/terraform/language/manage-sensitive-data)が導入され、Ephemeral valuesに対応する場合、その値はStateファイルで保存しなくなりました。2025年10月にterraform-provider-sops 1.3.0がEphemeral resourceに対応したことで、SOPSで暗号化したファイルを`git`に置きつつ、TerraformのStateファイルには機密情報を保存しない構成をとれます。

今回は、terraform-provider-sopsとEphemeral valuesを使ってTerraformで機密情報を安全に扱う方法を紹介します。

[:contents]

## 従来の課題点

TerraformでAWS環境を構築する際、SSM Parameter StoreやSecrets Managerに機密情報を登録する方法として、以下の2つが考えられます。

- AWSコンソールやaws cliで直接登録する
- Terraformで登録する

### AWSコンソールやaws cliで直接機密情報を登録する課題

Ephemeral resourceが登場するまでは、Terraformでこれらの値を入れるとStateファイルに平文で保存されてしまうため、AWSコンソールやaws cliで直接登録する方法がよく使われていました。しかしこの方法には以下のような問題点があります。

- 機密情報の登録を手動で行う必要があり、環境構築の自動化が難しい
- 誰がいつどのような値を登録したかの履歴がCloud Trailで確認するしかない
- どのような値が登録されているかをコードベースで把握できない
- 権限管理が必要なため、できる人、できない人が発生する

いずれもIaCが解決するべき課題であり、Terraformで機密情報を管理したいニーズは高いです。
Terraform Sateファイルに平文で保存されない方法があれば、Terraformで機密情報を管理することが可能になります。このため、Ephemeral valuesの登場は非常に大きな意味があります。

### Terraformで機密情報を登録する課題

もう1つ解決すべき問題は、機密情報をTerraformに渡す方法です。いくつか方法がありますが、代表的なものとして以下が挙げられます。

- 実行環境から環境変数経由で渡す
- Terraform実行時にコマンドライン引数で渡す
- 暗号化されたファイルから読み込む

環境変数経由やコマンドライン引数で渡す方法は、実行環境に機密情報を保持する必要があり、実行環境の管理が煩雑になる問題があります。また、どのような値を渡しているかをコードベースで把握できない問題もあります。

暗号化されたファイルから読み込む方法は、コードベースで把握できます。しかし、従来のTerraformではStateファイルに平文で保存されてしまう問題がありました。
terraform-provider-sopsがEphemeral resourceに対応したことで、SOPSで暗号化したファイルを`git`に置きつつ、TerraformのStateファイルには機密情報を保存しない構成をとれます。

## terraform-provider-sopsとEphemeral valuesを使って機密情報を安全に扱う

シークレットをコード管理しつつ、TerraformのStateファイルに平文で保存しない。両者の課題を解決できるのが、terraform-provider-sopsとEphemeral valuesを組み合わせた方法です。今回は、AWS SSM Parameter Storeに機密情報を登録する例[^1]を紹介します。

SOPSをTerraformで使うまで必要な手順は以下の通りです。1-3までは事前準備なので、一度構成してしまえば、通常通りTerraformリソースを書いて実行するだけです。

1. KMSキーの作成
2. SOPSで暗号化されたファイルの作成
3. TerraformでSOPSプロバイダーの設定
4. Terraformリソースの定義
5. Terraformの実行

## 実行環境

次の実行環境を用います。

- AWS KMS
- [SOPS](https://github.com/getsops/sops): v3.11.0
- [Terraform](https://github.com/hashicorp/terraform) v1.14.3 (v1.11.0以降が必要)
- [terraform-provider-sops](https://github.com/carlpett/terraform-provider-sops) v1.3.0 (v1.3.0以降が必要)

事前にTerraformとSOPSをインストールしておいてください。
sopsは、scoopやHomebrew、aquaなどでインストールできます。

### KMSキーの作成

SOPSの暗号化・復号に使用するKMSキーを作成します。以下のTerraformコードでKMSキーを作成します。

- key_usage: 暗号化・複合に使うのでENCRYPT_DECRYPT
- policy: IAMでKMSキーの利用を許可するポリシー
- alias: KMSキーを区別しやすいようにエイリアスを設定

KMS ARNは後でSOPSの設定で使用するため、出力しておきます。

```terraform
data "aws_caller_identity" "current" {}

resource "aws_kms_key" "main" {
  description             = "Terraform managed."
  deletion_window_in_days = 7
  enable_key_rotation     = true
  key_usage               = "ENCRYPT_DECRYPT"
  policy = jsonencode({
    "Version" : "2012-10-17",
    "Statement" : [
      {
        "Sid" : "Enable IAM User Permissions",
        "Effect" : "Allow",
        "Principal" : {
          "AWS" : "arn:aws:iam::${data.aws_caller_identity.current.account_id}:root"
        },
        "Action" : [
          "kms:*"
        ],
        "Resource" : "*"
      }
    ]
  })
}

resource "aws_kms_alias" "main" {
  name          = "alias/terraform-provider-sops"
  target_key_id = aws_kms_key.main.key_id
}

output "arn" {
  description = "KMS Key arn"
  value       = aws_kms_key.main.arn
}
```

IAM RoleやIAMユーザーにKMSキーの利用を許可するポリシーを設定してください。

```json
{
  "Sid": "Allow use of the key",
  "Effect": "Allow",
  "Action": [
    "kms:Encrypt",
    "kms:Decrypt",
    "kms:DescribeKey"
  ],
  "Resource": "*",
  "Principal": {
    "AWS": [
      "arn:aws:iam::123456789012:role/sops-dev-xyz"
    ]
  }
}
```

### SOPSで暗号化されたファイルの作成

SOPSで暗号化されたファイル`.sops.yaml`を作成します。今回はfooフォルダでTerraformリソースを定義していると仮定して、`./foo/secrets.yaml`ファイルを作成します。`secrets.yaml`にSOPSで暗号化・複合するシークレットを設定、指定したKMS鍵で暗号化・複合するように設定します。

- path: 暗号化するシークレットが書かれたファイルパス
- kms: 先ほど作成したKMSキーのARN

```yaml
creation_rules:
  - path: ./foo/secrets.yaml
    kms: >-
      arn:aws:kms:ap-northeast-1:123456789012:key/01234567-1234-abcd-abcd-1234567890ab
```

SOPSで暗号化・複合操作する前に、事前にAWSアカウントの認証を取得しておきましょう。

```shell
# Identity Center (SSO) を使っている場合
aws sso login --profile YOUR_PROFILE

# aws loginを使っている場合
aws login --profile YOUR_PROFILE
```

`sops edit`コマンドを使うと、指定したファイルを自動的に復号してエディタで開きます。編集後に保存すると、自動的に暗号化されます。secrets.yamlファイルがなくても作成してくれるので、初回から使えて万能です。

```shell
AWS_PROFILE=YOUR_PROFILE sops edit ./foo/secrets.yaml
```

コマンドを実行すると、初期状態なら次のような内容でエディタが開きます。

```yaml
hello: Welcome to SOPS! Edit this file as you please!
example_key: example_value
# Example comment
example_array:
    - example_value1
    - example_value2
example_number: 1234.56789
example_booleans:
    - true
    - false
```

雑に編集して、次のようにfooとbarの2キーを持つYAMLファイルにします。

```yaml
foo: thisisasecretvalue
bar: 123456789
```

保存するとsecrets.yamlファイルが暗号化されます。内容を確認してみましょう。

```shell
$ cat ./foo/secrets.yaml
foo: ENC[AES256_GCM,data:Gm/K9H+V+tM8TFrO329WYlHh,iv:75K+UGidrBPFGGdseZvvoWkGRNG32LvTDAy59O2ZvsI=,tag:nueHHxln7AWZWVuE+JGlgw==,type:str]
bar: ENC[AES256_GCM,data:VAKgrrKJQzpK,iv:ZDiCPV247Om6xIV6EBLUFRaQuXoBazvogckLWoX+1Vo=,tag:nXiLbNX0qwWL4UgxYS/5DQ==,type:int]
sops:
    kms:
        - arn: arn:aws:kms:ap-northeast-1:123456789012:key/01234567-1234-abcd-abcd-1234567890ab
          created_at: "2026-01-06T16:57:47Z"
          enc: AQICAHiU+HnowUKfgMmUO2S0Jj9ScLimZ37vJyD1AVgeLYaUSgFIHwSL2H1eF7HzbrHGSAmSAAAAfjB8BgkqhkiG9w0BBwagbzBtAgEAMGgGCSqGSIb3DQEHATAeBglghkgBZQMEAS4wEQQMhgseKZ423Pb8ehrdAgEQgDuTdy3uTRjrppPambOmjwKH2eIS3JK6+6LhD/scB2K2eaSAq6+sNpI3p6fepoAS3EjeaCMTd7n5ieYFkg==
          aws_profile: ""
    lastmodified: "2026-01-06T16:59:12Z"
    mac: ENC[AES256_GCM,data:gpVk67OIWAWg+iyWUu9q7cmI/DcviR70f5e+cI7kvCnBj0bVPNKPrIs2zDg5eD1OnCo+PbQXexX8YTBt0uqFx2Wm5iJ3Dpa6zCru4F3si92lVCUswNyfDeHHp7eGoGO9CpDGYi5HkBpf6cqOLS7F/rigqmIEtkF0clFbpOMj1ak=,iv:SLzttBfFg4lNjI/XpRbHokUcJTe4PrsGqqRi2Fz6UyY=,tag:1IbgK2p2S6V8bUWawLdY9Q==,type:str]
    unencrypted_suffix: _unencrypted
    version: 3.11.0
```

### TerraformでSOPSプロバイダーの設定

TerraformでSOPSを扱えるterraform-provider-sopsプロバイダーを設定しましょう。sopsプロバイダーv1.3.0以降でEphemeral valuesに対応しています。
Terraformの設定ファイルに`carlpett/sops`プロバイダーを追加します。

```terraform
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "= 6.27.0"
    }
    sops = {
      source = "carlpett/sops"
      version = "= 1.3.0"
    }
  }
  required_version = "~> 1.14.0"
}
```

`terraform init`を実行すると、sopsプロバイダーがダウンロードされます。

```shell
$ cd foo
$ terraform init
... 省略
Initializing provider plugins...
- Finding carlpett/sops versions matching "1.3.0"...
- Reusing previous version of hashicorp/aws from the dependency lock file
- Installing carlpett/sops v1.3.0...
- Installed carlpett/sops v1.3.0 (self-signed, key ID 1468AC14E6819667)
- Using previously-installed hashicorp/aws v6.27.0
... 省略
```

これでTerraform実行時に自動的にsopsで複合されます。

### Terraformリソースの定義

SOPSで暗号化されたファイル`secrets.yaml`から値を取得し、SSM Parameter Storeに登録するTerraformリソースを定義します。SOPSプロバイダーにv1.3.0で追加されたエフェメラルリソース`ephemeral "sops_file"`を用いると、Stateファイルに値が保存されません。従来の`data "sops_file"`リソースはStateファイルに値が保存されてしまうため避けましょう。

`aws_ssm_parameter`はEphemeral valuesに対応しているため、ephemeralリソースから取得した値をそのまま渡せます。今回はわかりやすいよう、secrets.yamlの内容を複合したものをそのままSSM Parameter Storeに登録します。

ephemeralリソースから取得した値は`raw`属性でアクセスできます。rawしかないので個別の値へのアクセスはAPIとして提供されていません。
`aws_ssm_parameter`にEphemeral valuesを渡すには、`value_wo`属性を使います。`value_wo`属性に値を渡すと、その値はStateファイルに保存されません。また、`value_wo_version`属性には任意の文字列を指定します。値を変更したときはversionを変更すると、Terraformが変更を検知して更新します。

```terraform
ephemeral "sops_file" "secrets" {
  source_file = "secrets.yaml"
}

resource "aws_ssm_parameter" "main" {
  name  = "sops_secrets"
  type  = "String"
  value_wo = ephemeral.sops_file.secrets.raw
  value_wo_version = 1
}
```

terraform planを実行して、問題ないことを確認します。

```shell
$ terraform plan

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # aws_ssm_parameter.main will be created
  + resource "aws_ssm_parameter" "main" {
      + arn              = (known after apply)
      + data_type        = (known after apply)
      + has_value_wo     = (known after apply)
      + id               = (known after apply)
      + insecure_value   = (known after apply)
      + key_id           = (known after apply)
      + name             = "sops_secrets"
      + region           = "ap-northeast-1"
      + tier             = (known after apply)
      + type             = "String"
      + value            = (sensitive value)
      + value_wo         = (write-only attribute)
      + value_wo_version = 1
      + version          = (known after apply)
    }
```

`terraform apply`すると、SSM Parameter Storeに機密情報が登録されます。値が、secrets.yamlの内容と同じであることを確認しましょう。

```
foo: thisisasecretvalue
bar: 123456789
```

[f:id:guitarrapc_tech:20260111040826p:plain:alt=SSM Parameterにsecrets.yamlの内容が入る]<!--image.png-->

tfstateファイルを確認してみましょう。ephemeralリソースの値が`value`や`value_wo`に保存されていないことがわかります。いい感じですね。

```json
{
  "mode": "managed",
  "type": "aws_ssm_parameter",
  "name": "main",
  "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
  "instances": [
    {
      "schema_version": 0,
      "attributes": {
        "allowed_pattern": "",
        "arn": "arn:aws:ssm:ap-northeast-1:123456789012:parameter/sops_secrets",
        "data_type": "text",
        "description": "",
        "has_value_wo": true,
        "id": "sops_secrets",
        "insecure_value": null,
        "key_id": "",
        "name": "sops_secrets",
        "overwrite": null,
        "region": "ap-northeast-1",
        "tags": null,
        "tier": "Standard",
        "type": "String",
        "value": "",
        "value_wo": null,
        "value_wo_version": 1,
        "version": 1
      },
      "sensitive_attributes": [
        [
          {
            "type": "get_attr",
            "value": "value"
          }
        ],
        [
          {
            "type": "get_attr",
            "value": "value_wo"
          }
        ]
      ],
      "identity_schema_version": 0,
      "identity": {
        "account_id": "123456789012",
        "name": "sops_secrets",
        "region": "ap-northeast-1"
      },
      "private": "bnVsbA==",
      "dependencies": [
        "ephemeral.sops_file.secrets"
      ]
    }
  ]
}
```

## 個別の値を登録したい

terraform-provider-sopsのephemeralリソースは`raw`属性しか提供していないため、個別の値に直接アクセスできません。そこで、rawで取得したYAML/JSONコンテンツを`yamldecode`、`jsondecode`関数で分解します。先ほどのsecrets.yamlは、YAMLフォーマットで`foo`と`bar`のキーを持っているので、それぞれ個別に登録するには`yamldecode`関数を使います。

```terraform
ephemeral "sops_file" "secrets" {
  source_file = "secrets.yaml"
}

resource "aws_ssm_parameter" "foo" {
  name  = "sops_foo"
  type  = "String"
  value_wo = yamldecode(ephemeral.sops_file.secrets.raw).foo
  value_wo_version = 1
}

resource "aws_ssm_parameter" "bar" {
  name  = "sops_bar"
  type  = "String"
  value_wo = yamldecode(ephemeral.sops_file.secrets.raw).bar
  value_wo_version = 1
}

```

`terraform apply`を実行すると、SSM Parameter Storeに個別の値が登録されます。

sops_fooには、secrets.yamlのfooの値が入っています。

[f:id:guitarrapc_tech:20260111040832p:plain:alt=fooの値が入っていることが確認できる]<!--image-1.png-->

sops_barには、secrets.yamlのbarの値が入っています。

[f:id:guitarrapc_tech:20260111040838p:plain:alt=barの値が入っていることが確認できる]<!--image-2.png-->

## value_wo_versionを自動化する

`value_wo_version`属性は、値を変更したときに更新を検知するために使います。手動でバージョン番号を管理するのはミスを誘発するため自動化しましょう。値が変更されたらversionも変わってほしいので、値のハッシュ値を計算したいのですが、復号した値を計算式に直接渡すことはできません。

```terraform
locals {
  sops_secrets = yamldecode(ephemeral.sops_file.secrets.raw)
  sops_secrets_hash = sha256(local.sops_secrets) # これはダメ
}
```

このため、シークレットファイル全体のハッシュ値を用います。基本的にシークレットを更新したときしかファイルが変わらないこと、すでにSSM Parameter Storeに登録されている値を更新しても特に影響がないので問題ないため許容できます。

```terraform
ephemeral "sops_file" "secrets" {
  source_file = local.sops_secrets_path
}

locals {
  sops_secrets_path = "secrets.yaml"
  sops_secrets_hash = substr(filesha256(local.sops_secrets_path), 0, 8)
}

resource "aws_ssm_parameter" "main" {
  name  = "sops_secrets"
  type  = "String"
  value_wo = local.sops_secrets
  value_wo_version = local.sops_secrets_hash
}

resource "aws_ssm_parameter" "foo" {
  name  = "sops_foo"
  type  = "String"
  value_wo = local.sops_secrets.foo
  value_wo_version = local.sops_secrets_hash
}

resource "aws_ssm_parameter" "bar" {
  name  = "sops_bar"
  type  = "String"
  value_wo = local.sops_secrets.bar
  value_wo_version = local.sops_secrets_hash
}
```

この方法の欠点は、1つの値を更新やKMSキーのローテーションでもシークレットファイルは書き変わり、全シークレットが更新される気持ち悪さです。これが嫌な場合、個別にephemeralリソースを作成して分割する、あるいはvalue_wo_versionを手動で管理するのがいいでしょう。どれも微妙なので悩ましいものがあります。

## まとめ

terraformにおけるシークレット管理は、Ephemeral valuesの登場で大きく変わりました。`terraform-sops-provider`がEphemeral resourceに対応したことで、SOPSで暗号化されたファイルをコードベースで管理しつつ、TerraformのStateファイルに平文で保存しない構成がとれます。

インフラのコード化を進める上で、シークレット管理は避けて通れない課題です。今回の方法は、万が一Gitリポジトリが漏洩しても、KMSキーで保護されたシークレットファイルが守られるため、安全にコードベースでシークレットを管理できます。

おすすめです。

[^1]: Secrets Managerも同様ですが、簡単のためSSM Parameter Storeを使います。
