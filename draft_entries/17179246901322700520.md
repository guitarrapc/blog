---
Title: Dexをアプリケーションの裏に組み込みしてOIDC連携する際の制約
Category:
- Kubernetes
Date: 2025-11-19T00:00:00+09:00
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/17179246901322700520
PreviewURL: https://tech.guitarrapc.com/draft/entry/0gxSV7OBPzOCDQE0I-FbrRK9YTA
CustomPath: 2025/11/19/000000
Draft: true
---

Kubernetesにおいて、Dexを使ってOIDC連携しているアプリケーションは多くあります。
今回はアプリケーションのDex組み込み方法によってOIDC連携に制約が生まれることを[Devtron](https://devtron.ai/)を例に紹介します。

[:contents]

## Dexとは

[Dex](https://github.com/dexidp/dex)は、他のアプリケーションに対してOpenID Connect (OIDC)プロバイダーです。Kubernetesで動作するアプリケーションのOIDCプロバイダーとしてよく使われ、OIDC認証を用いたシングルサインオン(SSO)を提供しているのを見かけることが多いでしょう。

実際、Dexを使ってOIDC認証を提供していたツールの中には、独自のOIDC認証実装に移行しているものもあります。例えばArgoCDは当初Dexを使ってOIDC認証を提供していましたが、現在はArgoCDが直接OIDC通信します。個人的にも、Dexを使っているアプリケーションのOIDC連携は引っかかりが多いので避けたい気持ちもあります。

ということで、今回はDexを使っているアプリケーションのOIDC連携の制約をDevtronを例に紹介します。

## Dexの組み込み方法

Dexを使っているアプリケーションには大きく分けて2つの組み込み方法があります。

1. Dex独立ホスト: Dexが独自のHost URL（例: `dex.example.com`）を持ち、アプリケーションとは別のエンドポイントとして公開
2. Dexをアプリケーション内蔵: アプリケーションが単一のHost URLを持ち、その配下に`/api/dex`のようなパスでDexを統合する。この方式では、同じURLが「外部からのブラウザアクセス」と「Pod内部からのDex API呼び出し」の両方に使われる

ほとんどのアプリケーションは1の方法を採用しています。しかし、Devtronは2の方法を採用しており、これがOIDC連携に制約を生んでいます。

## DevtronとOIDC認証

DevtronのOIDC認証はDexを使って提供しており、これを使って任意のIdPを使ってDevtronにSSOログインできます。DevtronのOIDC認証の設定は次のような設定要素があります。

| 要素 | 説明 | 設定例 |
|---|---|---|
| URL | Dexの.well-known/openid-configurationエンドポイントURLのベースURL | `https://devtron.example.com/orchestrator` |
| name | Dexの任意の構成名 | `cognito` |
| id | Dexの任意の構成ID | `cognito` |
| clientID | OIDCクライアントID。IdPのクライアントIDを用いる | `••••••••` |
| clientSecret | OIDCクライアントシークレット。IdPのクライアントシークレットを用いる | `••••••••` |
| issuer | IdPのIssuer URL | `https://cognito-idp.REGION.amazonaws.com/REGION_USER-POOL-ID` |
| redirectURI | DevtronのOIDCコールバックURL。ブラウザアクセス時のURLホストに相当する | `https://devtron.example.com/orchestrator/api/dex/callback` |

DevtronのOIDC認証設定例は以下の通りです。

```yaml
# URL: https://devtron.example.com/orchestrator
name: cognito
id: cognito
config:
 claimMapping:
  groups: cognito:groups
 clientID: ••••••••
 clientSecret: ••••••••
 issuer: https://cognito-idp.REGION.amazonaws.com/USER-POOL-ID
 redirectURI: https://devtron.example.com/orchestrator/api/dex/callback
 scopes:
  - openid
  - email
  - profile
 userNameKey: cognito:username
```

https://devtron.example.com/orchestrator/api/dex/.well-known/openid-configurationエンドポイントにアクセスすると、DexのOIDCプロバイダー情報が取得できます。例えば、次のようなJSONレスポンスが返ってきます。

```json
{
  "issuer": "https://devtron.example.com/orchestrator/api/dex",
  "authorization_endpoint": "https://devtron.example.com/orchestrator/api/dex/auth",
  "token_endpoint": "https://devtron.example.com/orchestrator/api/dex/token",
  "jwks_uri": "https://devtron.example.com/orchestrator/api/dex/keys",
  "userinfo_endpoint": "https://devtron.example.com/orchestrator/api/dex/userinfo",
  "device_authorization_endpoint": "https://devtron.example.com/orchestrator/api/dex/device/code",
  "grant_types_supported": [
    "authorization_code",
    "refresh_token",
    "urn:ietf:params:oauth:grant-type:device_code"
  ],
  "response_types_supported": [
    "code"
  ],
  "subject_types_supported": [
    "public"
  ],
  "id_token_signing_alg_values_supported": [
    "RS256"
  ],
  "code_challenge_methods_supported": [
    "S256",
    "plain"
  ],
  "scopes_supported": [
    "openid",
    "email",
    "groups",
    "profile",
    "offline_access"
  ],
  "token_endpoint_auth_methods_supported": [
    "client_secret_basic",
    "client_secret_post"
  ],
  "claims_supported": [
    "iss",
    "sub",
    "aud",
    "iat",
    "exp",
    "email",
    "email_verified",
    "locale",
    "name",
    "preferred_username",
    "at_hash"
  ]
}
```

これを見て、「あれ？」と思いませんか?そう、DevtronのOIDC認証設定にはDexのHost URLを指定する項目がありません。なぜなら、DevtronはDexを独自のHost URLで提供しておらず、ブラウザアクセスURLの一部として提供しているからです。ということで、DevtronのOIDC認証設定にはDexのHost URLを指定する項目がなく、代わりに指定したURLをベースに`.well-known/openid-configuration`パスが追加されてDevtron内部のOIDCクライアントがこのエンドポイントにアクセスします。つまり、上記の例なら、OIDC認証で`https://devtron.example.com/orchestrator/api/dex/.well-known/openid-configuration`へアクセスが試みられるということです。

つまり、上記の例ならDevtronのアプリエンドポイント(=Dexのエンドポイント)をグローバルなエンドポイントとしているので、DevtronをホストしているpodからグローバルなdevtronエンドポイントにアクセスしてDexの`.well-known/openid-configuration`エンドポイントにアクセスできます。

このことがDevtronのOIDC認証に制約を生んでいます。

## port-forwardingでDex OIDC認証は動くのか

結論から言うと、port-forwardだけで完結させたまま、DevtronのOIDC認証は動作しません。これは、devtronは単一URLという前提で設計されており、そのURLを使って2つの役割を果たしているからです。

- ブラウザからアクセス元として信頼する(redirectURIの検証)
- Dexをたたく時のベースURLにも使う(`/api/dex/.well-known/openid-configuration`エンドポイントの構築)

localhost:8082でDevtronにアクセスする場合と、クラスター内部のサービス名でDevtronにアクセスする場合の違いは、以下の通りです。

| 設定項目 | localhost:8082の例 | cluster.localの例 |
|---|---|---|
| URL (ベースURL) | `http://localhost:8082/orchestrator` | `http://devtron-service.devtroncd.svc.cluster.local/orchestrator` |
| redirectURI | `http://localhost:8082/orchestrator/api/dex/callback` | `http://localhost:8082/orchestrator/api/dex/callback` |
| ブラウザアクセス | ✅ 成功 | ❌ 失敗（ブラウザからcluster.localに到達不可） |
| Pod内部アクセス | ❌ 失敗（Pod内localhostに到達不可） | ✅ 成功 |
| 結果 | connection refused | Invalid redirect URL |

設定例を交えて説明します。

### localhost:8082の例

よくあるport-forwardingでDevtronにアクセスする場合どうなるか考えてみましょう。port-forwardingでDevtronにアクセスする場合、ブラウザからは`localhost:8082`のようなURLでアクセスします。この場合の設定は以下のように見えますが、これは機能しません。

| 要素 | 説明 | 設定例 |
|---|---|---|
| URL | Dexの.well-known/openid-configurationエンドポイントURLのベースURL | `http://localhost:8082/orchestrator` |
| name | Dexの任意の構成名 | `cognito` |
| id | Dexの任意の構成ID | `cognito` |
| clientID | OIDCクライアントID。IdPのクライアントIDを用いる | `••••••••` |
| clientSecret | OIDCクライアントシークレット。IdPのクライアントシークレットを用いる | `••••••••` |
| issuer | IdPのIssuer URL | `https://cognito-idp.REGION.amazonaws.com/REGION_USER-POOL-ID` |
| redirectURI | DevtronのOIDCコールバックURL。ブラウザアクセス時のURLホストに相当する | `http://localhost:8082/orchestrator/api/dex/callback` |

DevtronのOIDC認証設定例は以下の通りです。

```yaml
# URL: http://localhost:8082/orchestrator
name: cognito
id: cognito
config:
 claimMapping:
  groups: cognito:groups
 clientID: ••••••••
 clientSecret: ••••••••
 issuer: https://cognito-idp.REGION.amazonaws.com/USER-POOL-ID
 redirectURI: http://localhost:8082/orchestrator/api/dex/callback
 scopes:
  - openid
  - email
  - profile
 userNameKey: cognito:username
```

OIDC認証を試みると次のようなエラーが発生します。

```
Failed to query provider "http://localhost:8082/orchestrator/api/dex": Get "http://localhost:8082/orchestrator/api/dex/.well-known/openid-configuration": dial tcp [::1]:8082: connect: connection refused
```

原因は、Devtronのpodから`http://localhost:8082/orchestrator/api/dex/.well-known/openid-configuration`にアクセスしようとするためです。`localhost:8082`はブラウザから見たDevtronのエンドポイントですが、Devtronのpodから見た`localhost:8082`はDevtronのpod自身を指しており、Devtronのpod内で動作しているDexエンドポイントにはアクセスできません。
具体的には、Devtronの初期時に[`NewUserAuthOidcHelperImpl`](https://github.com/devtron-labs/devtron/blob/v1.8.2/pkg/auth/authentication/UserAuthOidcHelper.go#L51-L69)にて`DexConfig`のURL設定を使って`client.GetOidcClient()`を呼び出し、その中で`{URL}/.well-known/openid-configuration`にアクセスしてOIDCプロバイダー情報を取得しようとします。`localhost:8082`はport-forwardで作られたローカルマシン上のトンネルであり、Kubernetes Pod内から見ると存在しないアドレスなので接続が拒否されます、それはそう。

この場合、このような検証が行われています。

- OK: ブラウザ側のURLと一致するので、RedirectURIの検証は通る
- NG: Devtronのpodから`http://localhost:8082/orchestrator/api/dex/.well-known/openid-configuration`にアクセスできないので、OIDCプロバイダー情報の取得に失敗する

### devtron-service.devtroncd.svc.cluster.localの例

先のlocalhost:8082でアクセスできなかった原因は、Devtronのpodから見た`localhost:8082`がDevtronのpod自身を指してしまうことでした。では、Devtronのpodから見たDevtronのサービス名でアクセスできるように設定すればどうでしょうか?例えば、Devtronのサービス名が`devtron-service.devtroncd.svc.cluster.local`であれば、クラスター内部のサービスアドレスなのでDevtronのpodからもアクセスできるはずです。では、次のように設定すればOIDC認証は機能するでしょうか?

この場合でも、リダイレクトURIはブラウザからアクセスするURLホストに相当するので、`localhost:8082`のままとなります。設定は以下のようになりますが、これも機能しません。

| 要素 | 説明 | 設定例 |
|---|---|---|
| URL | Dexの.well-known/openid-configurationエンドポイントURLのベースURL | `http://devtron-service.devtroncd.svc.cluster.local/orchestrator` |
| name | Dexの任意の構成名 | `cognito` |
| id | Dexの任意の構成ID | `cognito` |
| clientID | OIDCクライアントID。IdPのクライアントIDを用いる | `••••••••` |
| clientSecret | OIDCクライアントシークレット。IdPのクライアントシークレットを用いる | `••••••••` |
| issuer | IdPのIssuer URL | `https://cognito-idp.REGION.amazonaws.com/REGION_USER-POOL-ID` |
| redirectURI | DevtronのOIDCコールバックURL。ブラウザアクセス時のURLホストに相当する | `http://localhost:8082/orchestrator/api/dex/callback` |

DevtronのOIDC認証設定例は以下の通りです。

```yaml
# URL: http://devtron-service.devtroncd.svc.cluster.local/orchestrator
name: cognito
id: cognito
config:
 claimMapping:
  groups: cognito:groups
 clientID: ••••••••
 clientSecret: ••••••••
 issuer: https://cognito-idp.REGION.amazonaws.com/USER-POOL-ID
 redirectURI: http://localhost:8082/orchestrator/api/dex/callback
 scopes:
  - openid
  - email
  - profile
 userNameKey: cognito:username
```

OIDC認証を試みると次のようなエラーが発生します。

```
Invalid redirect URL: the protocol and host (including port) must match and the path must be within allowed URLs if provided
```

クラスター内部のSVC URLを用いることで、Podからは疎通できるのですが、リダイレクトURI`localhost:8082`とhost+portが違うので検証エラーになっています。

この場合、このような検証が行われています。

- NG: リダイレクトURLとBaseURLのhost+portが一致しないので、RedirectURIの検証に失敗する
- OK: Devtronのpodから`http://devtron-service.devtroncd.svc.cluster.local/orchestrator/api/dex/.well-known/openid-configuration`はアクセスできる

## まとめ

DevtronのOIDC認証はDexを使って提供されていますが、DevtronはHost URLを1つ持っていて、そのURLを経路の異なるアクセスの両方に使っているため、port-forwardingだけで完結させたままOIDC認証を動作させることはできません。

- クライアント側(ブラウザ): OIDC認証フローのリダイレクトURL生成とコールバック検証
- サーバー側(Pod内部): Dexサービスへの直接接続と`.well-known/openid-configuration`の取得

Devtronのアーキテクチャはこの2つの経路で同じURLが到達可能であることを前提としているため、port-forwardingのみでOIDC認証を完全に動作させることはできません。

解決策ですが、DevtronのOIDC認証を使う場合は、IngressやLoadBalancerを使って内外両方からアクセスを担保できる統一されたエンドポイントを用意しましょう。ただし、このエンドポイントはDevtronのPodが起動しているNodeからもアクセス可能である必要があるため、IP制限でNodeを考慮する必要がありこれはこれで厄介です。
