---
Title: GitHub Actionsからgit pushをするパターン
Category:
- GitHubActions
- CI/CD
Date: 2025-12-09T23:00:00+09:00
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/17179246901331214009
PreviewURL: https://tech.guitarrapc.com/draft/entry/z_PkESI2OxAP1EL-ZBkigQTKJk4
CustomPath: 2025/12/13/230000
Draft: true
---

GitHub Actionsからの`git push`を実行する機会は少なくありません。例えば自動フォーマッタやドキュメント生成、特定ファイルの中身を更新などをした人は多いんじゃないでしょうか。
今回は、GitHub Actionsで`git push`をするときに私がやっている方法を紹介します。

[:contents]

## はじめに

Github Actionsのワークフローは基本的に並列に動作します。厳密には制御しえますが、GitHub Actionsとしては並列に動作することを前提に設計されており、直列実行をサポートする機能は限定的と言わざるを得ません。これと相性悪いのが、GitHub Actionsからの`git push`です。同一リモートrefに対して複数のワークフローやジョブが`git push`を実行すると、競合が発生してしまうためです。とはいえ、GitHub ActionsからのpushでPRを用意するのは運用的に面倒ですし、できれば同一ブランチに直接pushしたいところです。

よくある2つのパターンで、私がやっている方法を紹介します。

1. 同一ワークフローでのジョブごとにpushしたくなったら
2. 複数ワークフローでpushしたくなったら

## 同一ワークフローでのジョブごとにpushしたくなったら

同一ワークフローで複数の`git push`をしたくなる例として、Matrixを使うケースがあります。よくあるのがマルチプラットフォーム向けのビルドです。Linux、Windows、Mac OS向けにビルドして、それぞれの成果物を同一ブランチにpushしたい、みたいなケースが想像しやすいでしょう。

- ジョブAでOSごとに並列実行して`git push`を実行

素直にワークフローを書くと以下のようになります。[^1]ただ、これは最初にpushしたジョブ[^2]は成功しますが、後からpushしようとしたジョブはcheckout時点と比べてリモートが更新されているため`git push`は失敗します。

```yaml
# 省略....

jobs:
  build:
    permissions:
      contents: write
    strategy:
      matrix:
        build-os: ["linux_x64", "linux_arm64", "windows_x64", "windows_arm64", "macos_arm64"]
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false
      - name: Build
        run: |
          echo "do build"
          echo "build artifact ${{ runner.os }}/${{ runner.arch }}" >> .publish/binary_${{ runner.os }}/${{ runner.arch }}
      - name: Configure git for push
        run: |
          git remote set-url origin "https://github-actions:${GITHUB_TOKEN}@github.com/${{ github.repository }}"
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Commit build output
        run: |
          git switch -c "auto/create_pr" || git switch "auto/create_pr"
          git add .
          git commit -m "[automote] add build artifact for ${{ runner.os }}/${{ runner.arch }}"
          git push origin HEAD:${{ github.ref }} # <-- ここでリモート更新済みのためエラーが出る
```

この場合、`git push`を実行するジョブを分離して1回にしましょう。例えば以下のようにします。

```yaml
# 省略....

jobs:
  build:
    permissions:
      contents: read # pushしないのでreadだけでOK
    strategy:
      matrix:
        build-os: ["linux_x64", "linux_arm64", "windows_x64", "windows_arm64", "macos_arm64"]
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    outputs:
      build-artifacts: ${{ steps.set-artifacts.outputs.build-artifacts }}
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false
      - name: Build
        run: |
          echo "do build"
          echo "build artifact ${{ runner.os }}/${{ runner.arch }}" >> .publish/binary_${{ runner.os }}/${{ runner.arch }}
      - uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: artifact
          path: .publish/
          retention-days: 1

  push:
    needs: build
    permissions:
      contents: write
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false
      - uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
        with:
          name: artifact
          path: . # ダウンロード先があれば指定する
      - name: Configure git for push
        run: |
          git remote set-url origin "https://github-actions:${GITHUB_TOKEN}@github.com/${{ github.repository }}"
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Commit build output
        run: |
          git git checkout -b "${NEW_BRANCH_NAME}"
          git add .
          git commit -m "[automote] add build artifact for ${{ runner.os }}/${{ runner.arch }}"
          git push -u origin "${NEW_BRANCH_NAME}"
        env:
          NEW_BRANCH_NAME: auto/create_pr
```

## 複数ワークフローでpushしたくなったら

例えば、ドキュメント生成ワークフローとソースコードフォーマッターワークフローがあって、両方とも同一ブランチにpushしたい、みたいなケースを考えましょう。

- ワークフローAでDocs/のファイルを更新してpush
- ワークフローBでSrc/のフォーマッターを実行してpush

このような場合、最初にpushしたワークフローやジョブは成功しますが、後からpushしようとしたワークフローはcheckout時点と比べてリモートが更新されており、pushに失敗します。

```yaml
- name: git push
  shell: bash
  run: |
    git git checkout -b "${NEW_BRANCH_NAME}"
    git add .
    git commit -m "[automote] foobar"
    git push -u origin "${NEW_BRANCH_NAME}"
```

ワークフローの実行順序は保証されていないため、複数ワークフローが同一ブランチにpushする場合はリトライロジックを入れるのがおすすめです。以下の例は、リモートが更新されてpushに失敗した場合、`git pull --rebase`でリモートの変更を取り込んでから再度pushを試みる例です。最大3回までリトライします。

```yaml
- name: git commit
  run: |
    git git checkout -b "${NEW_BRANCH_NAME}"
    git add .
    git commit -m "[automote] foobar"
- name: git push
  shell: bash
  run: |
    max_retries=3
    retry_count=0

    while [ $retry_count -lt $max_retries ]; do
      echo "try 'git push' ($((retry_count + 1))/${max_retries}) ..."
      if git push origin "$GIT_REF"; then
        echo "Push succeeded."
        exit 0
      fi

      # Push failed, increment retry count
      ((retry_count++))

      # If we haven't exceeded max retries, try to rebase and retry
      if [ $retry_count -lt $max_retries ]; then
        echo "Failed to push, try 'git pull --rebase' to resolve ..."
        if ! git pull origin "$GIT_REF" --rebase; then
          echo "'git pull --rebase' has problem, you need resolve conflict ..."
          exit 1
        fi
        echo "Rebase succeeded, will retry push."
      fi
    done

    echo "max retry reached, but failed to push."
    exit 1
```

## まとめ

GitHub Actionsからの`git push`は競合が発生しやすいため、工夫が必要です。今回は2つのパターンでの対処法を紹介しました。
他にもいろいろなやり方がありますが、基本的には以下のポイントを押さえておけば大丈夫でしょう。

- 同一ワークフロー内で複数ジョブがpushする場合は、pushを1つのジョブにまとめる
- 複数ワークフローがpushする場合は、リトライロジックを入れる

## 補足: お約束

ワークフローで使っている、どのパターンでも共通するお約束です。

### Permissionsを指定する

Permissionsは原則指定しましょう。`git push`をする場合は`contents: write`が必要です。

```yaml
# NG
# permissionsがない

# OK
permissions:
  contents: write
```

### timeout-minutesを指定する

ジョブのタイムアウトは指定しましょう。デフォルトは6時間ですが、ビルドや`git push`だけなら3-5分もあれば十分なはずです。

```yaml
# NG
# timeout-minutesがない

# OK
timeout-minutes: 3
```

### SHA指定でactions/checkoutを使う

3rd partyアクションは基本的にSHA指定でバージョンを固定して使いましょう。

```yaml
# NG
- uses: actions/checkout@v5

# OK
- uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
```

### actions/checkoutはpersist-credentialsを無効にする

```yaml
# NG
- uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

# OK
- uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
  with:
    persist-credentials: false
```

この場合、Git push時に認証情報がないため、後述のGITHUB_TOKENを使った認証が必要になります。

### GitコンフィグでリモートURLとユーザー情報を設定する

`git push`するときに、GitHub Actionsのボットユーザー情報を設定しましょう。お決まりのメアドとユーザー名があります。
また、`persist-credentials: false`を指定した場合は、リモートURLに`${{ secrets.GITHUB_TOKEN }}`を埋め込む必要があります。

```yaml
# NG
# いきなりgit pushしようとする
# set-urlをしないでpushしようとする

# OK
- name: Configure git for push
  run: |
    git remote set-url origin "https://github-actions:${GITHUB_TOKEN}@github.com/${{ github.repository }}"
    git config user.name  "github-actions[bot]"
    git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```


[^1]: ジョブごとにrunnerを切り替えることが多いでしょうが、Goのようにあるプラットフォームからマルチプラットフォーム向けにビルドできるケースということで
[^2]: どのジョブが先に実行されるかは不定です。Matrixで`max-parallel: 1`にして直列にしても結局、後続のジョブは失敗します。
