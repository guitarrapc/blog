---
Title: SkiaSharp.QrCodeをフルリファクタしてC#最速のQRコード生成ライブラリにした
Category:
- C#
Date: 2025-11-10T19:00:00+09:00
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/17179246901309516294
PreviewURL: https://tech.guitarrapc.com/draft/entry/GkjrDi--9p5J6au390_Ko04k140
CustomPath: 2025/11/10/190000
---

SkiaSharp.QrCodeはC#でQRコードを生成するためのライブラリです。コードは大きく2要素で構成されており、QRコードデータの生成とSkiaSharpインテグレーションによるレンダリングから成り立っています。
今回、QRコードデータ生成部分をフルリファクタリングしてC#で最速のQRコード生成ライブラリに仕上げました。
また、他のQRコード生成ライブラリやシリアライザから使い勝手を見直してAPIも改善しました。

今回はSkiaSharp.QrCodeでQRコードを生成する例や、リファクタリングの備忘録です。

[:contents]

## リファクタリングの背景

SkiaSharp.QrCodeは元々、Azure Functions上でQRコードを高速に生成する必要があったために開発しました。
当時はC#でQRコードを生成するライブラリが少なく、またAzure Functions上でSystem.Drawingに依存しないQRコード生成ライブラリが必要だったのです。
用途的にもパフォーマンスはどうでもよく、とにかく動けば良いというスタンスで開発を進めました。

その後、私自身がQRコードを活用する機会が減ったこともありライブラリを半ば放置していたのですが、最近になって使い勝手の面とSkiaSharp最新版でビルド通らなくなった問題が気になり始めました。先日、NuGetのTrusted Publishing対応の一環でメンテをするしない判断をしていて、やる気になったので全面的に見直しました。

## 主な改善点

リファクタリングの目的は、QRコード生成のパフォーマンス向上とAPIの使い勝手改善です。特にQRコード生成を最速にし、メモリアロケーションを限りなくゼロに近づけることを目指しました。また、API面では`IDisposable`を廃止しユーザーがアロケーションを気にする必要がなくなること、`IBufferWriter`を活用してユーザーが任意のメモリ管理をできるようにすることを目指しました。レンダリング回りでも、静的な簡易メソッドと柔軟なBuilder APIの両方を提供することで、様々なユースケースに対応できるよう変更しました。

具体的な改善点は以下の通りです。ライブラリは引き続き.NET Standard 2.0, 2.1をサポートしつつ、.NET 8以降でSIMD命令を活用できるようにしています。

- QRコードにするデータをバイナリ形式のまま扱えるように変更、QRコードデータの生成過程での変換コストを削除
- QRコードデータ生成部分のアルゴリズムを最適化、パイプライン形式に処理を当てられるように内部APIを整理
- 処理量が大きく増える箇所はSIMD命令へ分岐
- 内部処理にstruct、Span、ArrayPoolを活用してQRコードデータ生成過程のGCゴミをゼロに、必要なメモリはQRコードデータのバイナリのみ
- 既存のQRコード生成結果を破壊しないようにユニットテストを整備
- NativeAOT対応
- QRコード生成部分のベンチマークを見つつパフォーマンスチューニング

## パフォーマンス比較

パフォーマンスやAPI変更は0.9.0で導入しました。0.8.0と0.9.0のパフォーマンスを比較した結果が以下の通りです。0.8.0はパフォーマンスを無考慮だったこともあり、0.9.0で見られる数字になっています。

| ケース | 速度向上率 | メモリ使用の減少率 | 備考 |
| --- | --- | --- | --- |
| URL 26文字 (L) | 34倍高速化 | 1/1637 | 最終的なバイナリデータ+クワイエットゾーン分の696Bのみ |
| ASCII 53文字 (L) | 57倍高速化 | 1/2182 | 最終的なバイナリデータ+クワイエットゾーン分の912Bのみ |
| ASCII 153文字 (Q) | 36倍高速化 | 1/3156 | 最終的なバイナリデータ+クワイエットゾーン分の3792Bのみ |

また、C#の他のQRコード生成ライブラリとのパフォーマンス比較も行いました。QRコード生成速度、メモリアロケーション共にSkiaSharp.QrCodeが最速、省メモリです。

[f:id:guitarrapc_tech:20251110191635p:plain:alt=C#のQRコードライブラリとの比較]<!--image-2.png-->

<details><summary>0.8.0のパフォーマンス</summary>

何も最適化していない状態です。

[f:id:guitarrapc_tech:20251110191642p:plain:alt=0.8.0のパフォーマンス]<!--image.png-->

</details>

<details><summary>0.9.0のパフォーマンス</summary>

[f:id:guitarrapc_tech:20251110191649p:plain:alt=0.9.0のパフォーマンス]<!--image-1.png-->

</details>

## 利用例

例えば、URL`https://example.com`をQRコードにしてPNG画像とする場合、以下のように書けます。

```cs
var pngBytes = QRCodeImageBuilder.GetPngBytes("https://example.com");
```

また、より柔軟に設定したい場合はBuilder APIを使うこともできます。

```cs
var pngBytes = new QRCodeImageBuilder("https://example.com")
    .WithSize(512, 512)
    .WithErrorCorrection(ECCLevel.H)
    .ToByteArray();
```

個人的にゴールとしたAPIは次のような書き味です。これはLinqPadでQRコードを生成して表示する例ですが、QrCoderがこのようなAPIを提供しており、SkiaSharp.QrCodeでも同様の使い勝手を提供したいと考えていたものです。

```cs
Bitmap.FromStream(new MemoryStream(QRCodeImageBuilder.GetPngBytes("WIFI:T:WPA;S:mynetwork;P:mypass;;"))).Dump();
```

[f:id:guitarrapc_tech:20251110191657p:plain:alt=LINQPadでQRコード表示]<!--image-3.png-->

### QRコードデータ部分だけを生成する

SkiaSharp.QrCodeはQRコードデータ生成部分とSkiaSharpインテグレーション部分が分離されているため、QRコードデータ部分だけ利用できます。例えば、他のライブラリでレンダリングしたり、コンソールアプリケーション上でQRコードを表示したりできます。

```cs
// サンプルコード: https://github.com/guitarrapc/SkiaSharp.QrCode/blob/d1d95d53354c503d6841491022aa009f84627356/samples/ConsoleApp/Program.cs

// コンソールアプリケーション上でemojiを表示するため出力エンコーディングをUTF-8に設定
Console.OutputEncoding = System.Text.Encoding.UTF8;

// QRコードデータ部分(QuietZoneを含む)を生成
var qrCodeData = QRCodeGenerator.CreateQrCode("https://example.com/foo/bar?path=123", ECCLevel.H);

// qrCodeDataの配列にrow/colでアクセスしてQRコードを任意の文字で表示
for (var row = 0; row < qrCodeData.Size; row++)
{
    for (var col = 0; col < qrCodeData.Size; col++)
    {
        Console.Write(qrCodeData[row, col] ? "🔵" : "  ");
    }
    Console.Write("\n");
}
```

[f:id:guitarrapc_tech:20251110191705p:plain:alt=コンソールアプリケーションでemojiを使ってQRコード表示]<!--image-4.png-->

これを利用してQRコードデータ自身のシリアライズ、デシリアライズも可能です。レンダリング情報を含まないため、コンパクトに保存できます。`QrCodeData.GetRawData(IBufferWriter<byte>)`オーバーロードを使うと、ユーザーが用意したバッファに直接書き込むこともできます。

```cs
// QRコードデータ部分(QuietZoneを含む)を生成
var qrCodeData = QRCodeGenerator.CreateQrCode("https://example.com/foo/bar?path=123", ECCLevel.H);

// QRコードデータをバイナリ配列にシリアライズ。
var serialized = qrCodeData.GetRawData();

// バイナリ配列からQRコードデータを復元 (quietzone: 4 はCreateQrCodeのデフォルト値)
var deserialized = new QRCodeData(serialized, quietZoneSize: 4);
```

### Instagram風のカラフルQRコードを生成する

QRコードはアプリケーション同士のユーザー情報や特定のデータを共有するために使われることが多いです。例えばInstagramでは、プロフィールページをQRコードで共有できます。このQRコードはInstagramのブランドカラーであるグラデーションカラーが使われており、視覚的に魅力的です。
SkiaSharp.QrCodeを使うと、このようなカラフルなQRコードも簡単に生成できます。以下はInstagram風のグラデーションカラーを使ったQRコード生成例です。

細かいことをいうと、InstagramはQRコードの●モジュールサイズをランダムに変化させているため、完全に同じにはなりませんが、近い見た目のQRコードを生成できます。

```cs
var content = "https://github.com/guitarrapc/SkiaSharp.QrCode/blob/main/README.md?foo=sample&bar=dummy";
var iconInstaPath = @"./samples/ConsoleApp/samples/insta.png";

// Instagram gradient colors (orange -> pink -> purple)
var instagramGradient = new GradientOptions(
    [
        SKColor.Parse("FCAF45"),  // Orange
        SKColor.Parse("F77737"),  // Orange-Red
        SKColor.Parse("E1306C"),  // Pink
        SKColor.Parse("C13584"),  // Purple
        SKColor.Parse("833AB4")   // Deep Purple
    ],
    GradientDirection.TopLeftToBottomRight,
    [0f, 0.25f, 0.5f, 0.75f, 1f]);

// Load Instagram logo (if you have one)
// For this example, we'll use the test icon
using var logo = SKBitmap.Decode(File.ReadAllBytes(iconInstaPath));
var icon = new IconData
{
    Icon = logo,
    IconSizePercent = 11,
    IconBorderWidth = 20,
};

var qrBuilder = new QRCodeImageBuilder(content)
    .WithSize(1024, 1024)
    .WithErrorCorrection(ECCLevel.H) // IconDataでデータを意図的に欠損しているのでH推奨
    .WithQuietZone(4)
    .WithColors(
        backgroundColor: SKColors.White,
        clearColor: SKColors.White)
    .WithModuleShape(CircleModuleShape.Default, sizePercent: 0.95f)
    .WithGradient(instagramGradient)
    .WithIcon(icon);

var pngBytes = qrBuilder.ToByteArray();
Bitmap.FromStream(new MemoryStream(pngBytes)).Dump();
```

[f:id:guitarrapc_tech:20251110191713p:plain:alt=Instagram風QRコード]<!--image-5.png-->

## リファクタリング

リファクタリング前にデータ整合性とパフォーマンスを測定できるようにします。これだけはリファクタリング前にやっておかないと、リファクタリング後に動作が変わってしまった場合に原因を特定できなくなるためです。具体的には以下の2点を実施しました。

1. リファクタリング前のコードでQRコードを生成し、生成結果が同一であることを確認するユニットテストを整備 (以前からあったのでデータ回りを中心に拡充)
2. ベンチマークコードを用意して、パフォーマンスやメモリの使用状況を測定できるようにする

QRコードは究極的にいうとただの0/1バイナリ配列なので、リファクタリング前後で生成されるQRコードデータが完全に同一であれば、リファクタリング前後で動作が変わってしまうことはありません。ユニットテストで生成結果の整合性を確認できるようにした上で、ベンチマークを見ながら少しずつ内部実装を改善していきました。具体的には以下の2つのIssueで改善を進めました。

- [[EPIC] QRCodeGenerator API Path Memory Optimization · Issue #164 · guitarrapc/SkiaSharp.QrCode](https://github.com/guitarrapc/SkiaSharp.QrCode/issues/164)
- [[EPIC] QRCodeGenerator API Path Performance Optimization · Issue #222 · guitarrapc/SkiaSharp.QrCode](https://github.com/guitarrapc/SkiaSharp.QrCode/issues/222)

### リファクタリング方針

リファクタリングの方針としては、以下の3点を重視して進めました。パブリックAPIは基本ノータッチ[^1]で、内部APIを変更し、パフォーマンスとメモリ使用量を削減しています。QRコード生成処理をパイプライン的にあてられるよう整理して、文字列版とバイナリ版の2系統でAPI互換性を保ちながら進めることで、途中段階でも文字列実装とバイナリ実装を比較しつつパフォーマンス測定ができるようにしました。

- 内部処理をパイプライン形式に整理し、SIMD命令や各処理を最適化しやすくする
- 内部表現をバイナリ化、文字列変換を排除 (途中まではバイナリ版と文字列版の2系統でAPI互換性を保ちながら進めて、最後に`text.AsSpan()`でバイナリ版に統一)
- QRコードデータ表現をBitArrayベースから1次元配列+インデクサに変更し、メモリ効率やアクセス効率を改善

### メモリ改善

メモリ改善に最も効果があったのは、次の5点です。最も効果が大きいのはバイナリ化ですが、ゼロアロケーションを目指す上でstruct/Span/stackalloc/ArrayPoolの活用が欠かせません。地味にLINQ排除も効果が大きく、特にQRコードデータは内部の点(モジュール)の数だけループを回す必要があるため、LINQのオーバーヘッドが積み重なっていました。データ構造を1次元配列にビンパックすることで、メモリ使用量とアクセス効率が改善しました。とどめは、ある処理で不用意にリフレクションを行っていたため、switch式ベースに変更してメモリを一気に削除しました。

- 内部処理はバイナリ直接アクセスに変更し、文字列変換を排除
- 内部処理にstruct、Span、stackalloc/ArrayPoolを活用してGCゴミを削減
- LINQを排除し、ループベースの処理に変更
- `List<BitArray>`の2次元配列を廃止し、1次元配列+インデクサに変更
- 不要なリフレクションを排除して、switch式ベースでメソッド分岐に変更

classからstructへの変更

[f:id:guitarrapc_tech:20251110191722p:plain:alt=classからstructへの変更]<!--image-6.png-->

LINQの線形探索をルックアップテーブルに変更

[f:id:guitarrapc_tech:20251110191729p:plain:alt=LINQの線形探索をルックアップテーブルに変更]<!--image-7.png-->

QRCode表現をBitArrayから1次元バイナリに変更

[f:id:guitarrapc_tech:20251110191736p:plain:alt=QRCode表現をBitArrayから1次元バイナリに変更]<!--image-8.png-->

マスク処理のリフレクションをswitchベースの分岐に変更

[f:id:guitarrapc_tech:20251110191743p:plain:alt=マスク処理のリフレクションをswitchベースの分岐に変更]<!--image-9.png-->

### パフォーマンス改善

QRコードは、先ほど説明したようにモジュールアクセスがどうしても必要です。これは仕様にもある通り、8種類のマスクパターンから最適なものを選択するときにも必要ですし、エンコードしたデータをQRコードモジュールに配置するときにも必要です。特に、モジュールアクセスはQRコードのバージョンが上がると指数関数的に増えるため、ここをいかに高速化できるかがパフォーマンス改善の鍵となりました。あとは、ループに関係ないマスク処理のmod/div演算をテーブル化してO(1)にするのも計算量を減らすのに効果的でした。結局計算量を減らすのが一番効果ある。SIMD命令も一部入れていますが、データが大きくないと効果が薄いため、QRコードとSIMD命令の相性はあまり良くない印象です。

- モジュールアクセスのペナルティ計算ループを可能な限り減らす
- モジュール配置をrectangleを用いたブロックチェックからbitmaskに変更
- 事前計算できるmod/div演算をテーブル化して高速化
- モジュールアクセスをSIMD命令で高速化

モジュールアクセスのペナルティ計算ループを可能な限り減らす

[f:id:guitarrapc_tech:20251110191750p:plain:alt=モジュールアクセスのペナルティ計算ループを可能な限り減らす]<!--image-11.png-->

モジュール配置をrectangleを用いたブロックチェックからbitmaskに変更

[f:id:guitarrapc_tech:20251110191758p:plain:alt=モジュール配置をrectangleを用いたブロックチェックからbitmaskに変更]<!--image-10.png-->

事前計算できるmod/div演算をテーブル化して高速化

[f:id:guitarrapc_tech:20251110191806p:plain:alt=事前計算できるmod/div演算をテーブル化して高速化]<!--image-12.png-->

## 今後

いくつか今回の対応から、今後の目安をメモします。

### ゼロアロケーション

ゼロアロケーションは何度も検討しましたが、使い勝手と両立する道が見えず見送っています。理屈としては利用者が`IBufferWriter<byte>`を渡すAPIとすれば設計可能ですが、QuietZoneSizeを利用者が計算してレンダリングさせるのはちょっと厳しい印象です。今は1次元配列にしつつインデックスアクセスを提供することで、メモリ効率と使い勝手のバランスを取っています。将来的にゼロアロケーション版APIを追加する可能性はありますが、現状はアロケーションの小ささから見て優先度が低いと考えています。

### QRコードの読み取り

このライブラリでは対応する予定はありません。QRコードの読み取りは画像処理が絡むため、SkiaSharp.QrCodeの責務外と考えています。C#でQRコードを読み取る場合は、ZXing.Netなどの別ライブラリを利用することをオススメします。需要が大きくなったら考える

### rMQRなどの特殊QRコード

QRコードはDensoが特許を保持している形式(FrameQRとか)とISO/IECで仕様化されている形式(rMQRやMicro QR Code)、産業用途で利用されている、GS1 QR Codeなど様々なバリエーションがあります。SkiaSharp.QrCodeはISO/IEC 18004:2015で仕様化されている標準QRコードにのみ対応しています。

将来的に需要があれば、ISO化されているrMQRやMicro QR Codeなどの特殊QRコードにも対応してもよいと考えていますが、やるならこれらを読み取れる実機が欲しいです。だれか実機ください。[^2]

## まとめ

C#のQRCode生成を見直してC#で最速のQRコード生成ライブラリに仕上げました。パフォーマンスだけでなく使いやすくなっているので、C#でQRコードを生成する場合はぜひSkiaSharp.QrCodeを試してみてください。

[^1]: 最終的にいくつかのパラメーターを廃止したりと修正しましたが、パフォーマンス直結ではなくデータ構造としての無駄を排除する目的で行いました。
[^2]: 標準QRコードはiPhoneやAndroidスマホで読み取れますが、rMQRやMicro QR Codeは専用のリーダーが必要です。
