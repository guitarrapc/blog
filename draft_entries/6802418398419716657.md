---
Title: CloudFront Functionsでオリジンを書き換える
Date: 2025-04-10T23:59:00+09:00
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/6802418398419716657
PreviewURL: https://tech.guitarrapc.com/draft/entry/q-FjqDaSQqHIYiPMgZnqMySYjHo
CustomPath: 2025/04/10/235900
Draft: true
---

CloudFrontでオリジンを書き換えようと考えた時、これまではLambda@Edgeを利用していましたが、CloudFront JavaScript Runtime 2.0以降はCloudFront Functionsでもオリジンの書き換えが可能になりました。

[:contents]

# CloudFrontでオリジンを書き換えるケース

一般的に、リクエストを別の場所へ転送する場合は**リダイレクト（HTTP 3xx）**を利用するのが単純かつ扱いやすくです。特に`GET`リクエストは、クライアント（ブラウザやAPIクライアント）がリダイレクト先に再リクエストを送信するため、サーバーとしても扱いやすくほとんどのケースで問題なく動作します。

ただ、POSTリクエストを処理する場合は、リダイレクトは適さないことがあります。例えば、npmはPOSTリクエストのクライアントリダイレクトをサポートしていません。この場合、CloudFrontでオリジンを書き換えて、受け取ったPOSTリクエストを転送する必要があります。

単純にいうと、GETリクエストならリダイレクトで問題ないですが、POSTリクエストなどリダイレクトできないリクエストをCloudFrontで受け取る場合にオリジン書き換えを検討する必要があります。

# CloudFrontでオリジンを書き換える方法

CloudFrontでオリジンを書き換える方法は2つあります。

1. Lambda@Edgeを利用する
2. CloudFront Functionsを利用する

今回は、`/`や`/foo`はリダイレクト、`/npm`はオリジン書き換える例を示します。

**CloudFront Functionsでもオリジン書き換えが可能になった**

CloudFront Functionsは`Host`ヘッダーを書き換えできないため、JavaScript Runtime 1.0ではオリジン書き換えが出来ません。

[f:id:guitarrapc_tech:20250514200658p:plain:alt=ビューアリクエストイベントでHostヘッダーは書き換えられない]

しかしJavaScript Runtime 2.0に[updateRequestOriginメソッド](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/helper-functions-origin-modification.html#update-request-origin-helper-function)が追加されたことでCloudFront Functionsでもオリジン書き換えが可能になりました。

## Lambda@Edgeでオリジン書き換えをする

Lambda@Edgeを利用する場合、オリジンリクエストにLambda@Edgeを設定します。あとは、`Host`ヘッダーを書き換えてオリジン書き換えが可能です。なお、`request.origin.custom.domainName = domainName;`がなくてもオリジン書き換えは機能します。

Lambda@Edgeは月間100万リクエストまで無料です。また、リクエスト本文へのアクセスもでき、ビューアリクエストイベントで触らないヘッダー操作ができます。Lambda@Edgeは処理時間制約が緩いこともあり、ある程度複雑なこともできます。一方でただのオリジン書き換えにはオーバースペックです。

```js
'use strict';
exports.handler = (event, context, callback) => {
    const domainName = 'example.net';
    const request = event.Records[0].cf.request;
    const path = request.uri;

    switch (path) {
        case '/':
        case '/foo':
            // リダイレクト
            const response = {
                status: '301',
                statusDescription: 'Moved Permanently',
                headers: {
                    location: [{
                        key: 'Location',
                        value: `https://${domainName}` + path,
                    }],
                },
            };

            // リダイレクト用レスポンスをクライアントに返す
            callback(null, response);
            break;
        default:
            // リライト
            const clientIp = request.clientIp;
            request.origin.custom.domainName = domainName;
            request.headers['host'] = [{ key : 'host', value : domainName}];
            request.headers['x-forwarded-for'] = [{ key: 'X-Forwarded-For', value: clientIp }];

            // リライトはリクエストをアップストリームに転送する
            callback(null, request);
    }
};
```

## CloudFront Functionsでオリジン書き換えをする

CloudFront Functionsを利用する場合、ビューアリクエストイベントにCloudFront Functionsを設定します。また、CloudFrontはJavaScript Runtime 2.0あとは、`updateRequestOrigin`メソッドを利用してオリジン書き換えが可能です。

# Lambda@Edgeを使うかCloudFront Functionsを使うか

個人的には、リダイレクト、オリジン書き換えだけが目的ならCloudFront Functionsを利用するのが好ましいです。

Lambda@Edgeを避ける最大の理由はLambda@Edgeを利用するにはパブリッシュが必要なことです。これがあるために、Lambda@EdgeをIaCで管理していても、一度IaCでCloudFrontとLambda@Edgeの紐づけを削除、AWSがLambdaの公開を削除するまで待つ必要があります。AWSの削除タイミングは予測不明で、Lambda@EdgeからCloudFront Functionsに移行でも、毎度軽い手当が必要で嫌になってます。

関数本体というより周辺でかかるコストも避けたい理由です。Datadogなど監視系で「サーバーレス」課金対象になることです。CloudFront Functionsは「サーバーレス」課金対象にならず扱いやすい側面があります。

CloudWatch Logsの管理リージョンがばらつくのも嫌な点です。Lambda@EdgeはCloudFrontのエッジリージョンのCloudWatch Logsに出力されるため、ログがばらつきます。


# 参考

https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/helper-functions-origin-modification.html#update-request-origin-helper-function
