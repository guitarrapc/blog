---
Title: C# NativeAOTをDockerでビルドする
Category:
- C#
Date: 2025-11-23T03:00:00+09:00
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/17179246901324125736
PreviewURL: https://tech.guitarrapc.com/draft/entry/ILcYnMa4InqfFD4VpvkkE3K4e3Q
CustomPath: 2025/11/23/030000
Draft: true
---

[NativeAOT](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/?tabs=windows%2Cnet8)は、.NETアプリケーションをネイティブコードにコンパイルする技術です。
NativeAOTはJITではなくAOTでコンパイルするため、スタートアップ速度の向上、メモリフットプリントの小ささ、動作環境にランタイムが不要(JIT不可環境で動作)、デプロイメント簡素化に寄与します。

この記事では、C#のNativeAOTアプリケーションをDockerコンテナ内でビルドする方法について解説します。
ここ数年はコンテナもARM64環境で動作して当然となってきているため、.NETのNativeAOTサーバーもARM64対応しましょう。

[:contents]

## ゴール

この記事のゴールは、マルチプラットフォーム対応のコンテナビルドである次のコマンドを実行できるようにすることです。

```sh
$ docker buildx build --platform linux/amd64,linux/arm64 -f Dockerfile .
```

また、イメージサイズもできるだけ小さくしてみましょう。

## NativeAOTのプロジェクトを用意する

ASP.NET Core Web APIのNativeAOTプロジェクトを用意しましょう。以下のコマンドでプロジェクトを作成するとNativeAOT対応のWeb APIプロジェクトが作成されます。

```bash
dotnet new webapiaot
```

ただ、コマンドからはDockerfileが同時に生成されません。このため、今回はVisual Studio > Add > Container SupportでDockerfileを生成します。

![alt text](image-10.png)<!--image-10.png-->

次のようなDockerfileが生成されます。

```dockerfile
# See https://aka.ms/customizecontainer to learn how to customize your debug container and how Visual Studio uses this Dockerfile to build your images for faster debugging.

# These ARGs allow for swapping out the base used to make the final image when debugging from VS
ARG LAUNCHING_FROM_VS
# This sets the base image for final, but only if LAUNCHING_FROM_VS has been defined
ARG FINAL_BASE_IMAGE=${LAUNCHING_FROM_VS:+aotdebug}

# This stage is used when running from VS in fast mode (Default for Debug configuration)
FROM mcr.microsoft.com/dotnet/aspnet:10.0 AS base
USER $APP_UID
WORKDIR /app
EXPOSE 8080


# This stage is used to build the service project
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
# Install clang/zlib1g-dev dependencies for publishing to native
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
    clang zlib1g-dev
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["test.csproj", "."]
RUN dotnet restore "./test.csproj"
COPY . .
WORKDIR "/src/."
RUN dotnet build "./test.csproj" -c $BUILD_CONFIGURATION -o /app/build

# This stage is used to publish the service project to be copied to the final stage
FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./test.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=true

# This stage is used as the base for the final stage when launching from VS to support debugging in regular mode (Default when not using the Debug configuration)
FROM base AS aotdebug
USER root
# Install GDB to support native debugging
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
    gdb
USER app

# This stage is used in production or when running from VS in regular mode (Default when not using the Debug configuration)
FROM ${FINAL_BASE_IMAGE:-mcr.microsoft.com/dotnet/runtime-deps:10.0} AS final
WORKDIR /app
EXPOSE 8080
COPY --from=publish /app/publish .
ENTRYPOINT ["./test"]
```

この状態で、Visual StudioからDockerコンテナでデバッグ実行すると、NativeAOTアプリケーションがビルドされ、コンテナ内で実行されます。

![alt text](image-11.png)<!--image-11.png-->

```json
[{"id":1,"title":"Walk the dog","dueBy":null,"isComplete":false},{"id":2,"title":"Do the dishes","dueBy":"2025-11-22","isComplete":false},{"id":3,"title":"Do the laundry","dueBy":"2025-11-23","isComplete":false},{"id":4,"title":"Clean the bathroom","dueBy":null,"isComplete":false},{"id":5,"title":"Clean the car","dueBy":"2025-11-24","isComplete":false}]
```

このDockerfileはx64環境でのビルドである次のコマンドでのビルドに対応しています。

```sh
# amd64環境でプラットフォームを省略するとlinux/amd64と同義
$ docker buildx build -f Dockerfile .
# 直接指定してもいい
$ docker buildx build --platform linux/amd64 -t test -f Dockerfile .
```

これで下準備は完了です。

## NativeAOTアプリケーションをARM64でビルドする

次に、ARM64環境でNativeAOTアプリケーションをビルドできるようにDockerfileを修正します。
ここで、NativeAOTアプリケーションをARM64でコンテナビルドするために必要なことを解説します。

- クロスコンパイル用のツールチェインをインストールする `gcc-aarch64-linux-gnu libc6-dev-arm64-cross binutils-aarch64-linux-gnu`
- objcopyコマンドをクロスコンパイル用のものに置き換える `aarch64-linux-gnu-objcopy`
- `dotnet build`や`dotnet publish`のビルドターゲットに`-a arm64`を指定する
- Dockerfileのビルドステージでプラットフォームを受け取るため、ビルドステージに`--platform=$BUILDPLATFORM`を指定、ビルド引数に`ARG TARGETARCH`を追加

これらを踏まえて、Dockerfileを修正します。

```dockerfile
# See https://aka.ms/customizecontainer to learn how to customize your debug container and how Visual Studio uses this Dockerfile to build your images for faster debugging.

# These ARGs allow for swapping out the base used to make the final image when debugging from VS
ARG LAUNCHING_FROM_VS
# This sets the base image for final, but only if LAUNCHING_FROM_VS has been defined
ARG FINAL_BASE_IMAGE=${LAUNCHING_FROM_VS:+aotdebug}

# This stage is used when running from VS in fast mode (Default for Debug configuration)
FROM mcr.microsoft.com/dotnet/aspnet:10.0 AS base
USER $APP_UID
WORKDIR /app
EXPOSE 8080


# This stage is used to build the service project
FROM --platform=$BUILDPLATFORM mcr.microsoft.com/dotnet/sdk:10.0 AS build
ARG BUILD_CONFIGURATION=Release
ARG TARGETARCH
WORKDIR /src
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
    clang zlib1g-dev \
    && if [ "$TARGETARCH" = "arm64" ]; then apt-get install -y --no-install-recommends gcc-aarch64-linux-gnu libc6-dev-arm64-cross binutils-aarch64-linux-gnu; fi \
    && rm -rf /var/lib/apt/lists/*
COPY ["test.csproj", "."]
RUN dotnet restore "./test.csproj"
COPY . .
WORKDIR "/src/."
RUN dotnet build "./test.csproj" -c $BUILD_CONFIGURATION -a $TARGETARCH -o /app/build

# This stage is used to publish the service project to be copied to the final stage
FROM build AS publish
ARG BUILD_CONFIGURATION=Release
# Setup objcopy for ARM64 cross-compilation
RUN if [ "$TARGETARCH" = "arm64" ]; then ln -sf /usr/bin/aarch64-linux-gnu-objcopy /usr/local/bin/objcopy; fi
RUN dotnet publish "./test.csproj" -c $BUILD_CONFIGURATION -a $TARGETARCH -o /app/publish /p:UseAppHost=true

# This stage is used as the base for the final stage when launching from VS to support debugging in regular mode (Default when not using the Debug configuration)
FROM base AS aotdebug
USER root
# Install GDB to support native debugging
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
    gdb
USER app

# This stage is used in production or when running from VS in regular mode (Default when not using the Debug configuration)
FROM ${FINAL_BASE_IMAGE:-mcr.microsoft.com/dotnet/runtime-deps:10.0-noble-chiseled-extra} AS final
WORKDIR /app
EXPOSE 8080
COPY --from=publish /app/publish .
ENTRYPOINT ["./test"]
```

以下はARM64対応したDockerfileの差分です。
主要なコマンドはいじらずに対応できているのが分かります。注意点として、`ARG TARGETARCH`はビルドステージの頭で追加してください。AMD64/ARM64プラットフォーム別にコマンドを変える条件分離を入れるためです。

```diff
- FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
+ FROM --platform=$BUILDPLATFORM mcr.microsoft.com/dotnet/sdk:10.0 AS build
ARG BUILD_CONFIGURATION=Release
+ ARG TARGETARCH
WORKDIR /src
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
    clang zlib1g-dev \
+     && if [ "$TARGETARCH" = "arm64" ]; then apt-get install -y --no-install-recommends gcc-aarch64-linux-gnu libc6-dev-arm64-cross binutils-aarch64-linux-gnu; fi \
+     && rm -rf /var/lib/apt/lists/*
COPY ["test.csproj", "."]
RUN dotnet restore "./test.csproj"
COPY . .
WORKDIR "/src/."
- RUN dotnet build "./test.csproj" -c $BUILD_CONFIGURATION -o /app/build
+ RUN dotnet build "./test.csproj" -c $BUILD_CONFIGURATION -a $TARGETARCH -o /app/build

# This stage is used to publish the service project to be copied to the final stage
FROM build AS publish
ARG BUILD_CONFIGURATION=Release
+ # Setup objcopy for ARM64 cross-compilation
+ RUN if [ "$TARGETARCH" = "arm64" ]; then ln -sf /usr/bin/aarch64-linux-gnu-objcopy /usr/local/bin/objcopy; fi
- RUN dotnet publish "./test.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=true
+ RUN dotnet publish "./test.csproj" -c $BUILD_CONFIGURATION -a $TARGETARCH -o /app/publish /p:UseAppHost=true
```

それでは、修正したDockerfileでマルチプラットフォームビルドを実行しましょう。

```sh
$ docker buildx build --platform linux/amd64,linux/arm64 -t test -f Dockerfile .
[+] Building 265.8s (31/31) FINISHED                                                               docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                               0.0s
 => => transferring dockerfile: 2.37kB                                                                             0.0s
 => [linux/amd64 internal] load metadata for mcr.microsoft.com/dotnet/runtime-deps:10.0                            1.2s
 => [linux/amd64 internal] load metadata for mcr.microsoft.com/dotnet/sdk:10.0                                     1.2s
 => [linux/arm64 internal] load metadata for mcr.microsoft.com/dotnet/runtime-deps:10.0                            1.5s
 => [internal] load .dockerignore                                                                                  0.0s
 => => transferring context: 464B                                                                                  0.0s
 => [internal] load build context                                                                                  0.0s
 => => transferring context: 4.67kB                                                                                0.0s
 => [linux/arm64 final 1/3] FROM mcr.microsoft.com/dotnet/runtime-deps:10.0@sha256:69ee6d1a1b7a92cc82a71001342554  3.7s
 => => resolve mcr.microsoft.com/dotnet/runtime-deps:10.0@sha256:69ee6d1a1b7a92cc82a71001342554d4611a509d880114b2  0.0s
 => => sha256:7d9e1832d26ac2daa9e6af016a0da63d925a22c72c7673707338d057ccc3a068 3.56kB / 3.56kB                     0.4s
 => => sha256:97dd3f0ce510a30a2868ff104e9ff286ffc0ef01284aebe383ea81e85e26a415 28.86MB / 28.86MB                   2.0s
 => => sha256:5c57a8c859e2e325b62a2c81fc3da56db2274f2084df97f9fa118f751c1f0d76 16.79MB / 16.79MB                   3.2s
 => => extracting sha256:97dd3f0ce510a30a2868ff104e9ff286ffc0ef01284aebe383ea81e85e26a415                          0.9s
 => => extracting sha256:5c57a8c859e2e325b62a2c81fc3da56db2274f2084df97f9fa118f751c1f0d76                          0.4s
 => => extracting sha256:7d9e1832d26ac2daa9e6af016a0da63d925a22c72c7673707338d057ccc3a068                          0.0s
 => [linux/amd64 build 1/8] FROM mcr.microsoft.com/dotnet/sdk:10.0@sha256:c7445f141c04f1a6b454181bd098dcfa606c61  19.8s
 => => resolve mcr.microsoft.com/dotnet/sdk:10.0@sha256:c7445f141c04f1a6b454181bd098dcfa606c61ba0bd213d0a702489e5  0.0s
 => => sha256:60be9a169ff87b6d4f370e679741c0c2715471260372e4468e5cf5b1ed5e66bd 17.60MB / 17.60MB                   1.3s
 => => sha256:e1a43a11c338e681e5189550383f50b55854c0ca90d6a1b29b544eed52260c1e 492B / 492B                         0.1s
 => => sha256:cdb9f2f2f20d8b619a2ec71ca268aeb85d54781135d4ce6fe53b7f814b525e21 188.45MB / 188.45MB                14.0s
 => => sha256:82c9b8487b966e2a36d3591884c9f9dcb81a0a067522c3f057b69ad0c27210f8 23.60MB / 23.60MB                   2.2s
 => => sha256:ad3a33b726b12ed0a2013a69491146deda74c174c57edbfb0d07a7a536d1d1e5 12.76MB / 12.76MB                   2.6s
 => => sha256:cf846b836998163e04850ddb5c7e2210eb8c95bc0c221230c5d6a26cc7de63e7 155B / 155B                         0.1s
 => => sha256:66ecb3299fecbc0d05e411d7a62b0e25ba005c3ed4ad1ebdcd89c2692ab95415 36.71MB / 36.71MB                   3.0s
 => => extracting sha256:66ecb3299fecbc0d05e411d7a62b0e25ba005c3ed4ad1ebdcd89c2692ab95415                          0.3s
 => => extracting sha256:cf846b836998163e04850ddb5c7e2210eb8c95bc0c221230c5d6a26cc7de63e7                          0.0s
 => => extracting sha256:ad3a33b726b12ed0a2013a69491146deda74c174c57edbfb0d07a7a536d1d1e5                          0.1s
 => => extracting sha256:82c9b8487b966e2a36d3591884c9f9dcb81a0a067522c3f057b69ad0c27210f8                          0.6s
 => => extracting sha256:cdb9f2f2f20d8b619a2ec71ca268aeb85d54781135d4ce6fe53b7f814b525e21                          2.2s
 => => extracting sha256:e1a43a11c338e681e5189550383f50b55854c0ca90d6a1b29b544eed52260c1e                          0.0s
 => => extracting sha256:60be9a169ff87b6d4f370e679741c0c2715471260372e4468e5cf5b1ed5e66bd                          0.2s
 => [linux/amd64 final 1/3] FROM mcr.microsoft.com/dotnet/runtime-deps:10.0@sha256:69ee6d1a1b7a92cc82a71001342554  8.1s
 => => resolve mcr.microsoft.com/dotnet/runtime-deps:10.0@sha256:69ee6d1a1b7a92cc82a71001342554d4611a509d880114b2  0.0s
 => => sha256:e556599eb01843481eb2ced4641c7afea2a15f40af57aa236dae733bac7035f4 3.54kB / 3.54kB                     0.2s
 => => sha256:05a997a818e912916b5455ed2a572f4f1779812770cf6301e11fb2f86b92a136 16.82MB / 16.82MB                   3.1s
 => => sha256:20043066d3d5c78b45520c5707319835ac7d1f3d7f0dded0138ea0897d6a3188 29.72MB / 29.72MB                   6.5s
 => => extracting sha256:20043066d3d5c78b45520c5707319835ac7d1f3d7f0dded0138ea0897d6a3188                          0.8s
 => => extracting sha256:05a997a818e912916b5455ed2a572f4f1779812770cf6301e11fb2f86b92a136                          0.4s
 => => extracting sha256:e556599eb01843481eb2ced4641c7afea2a15f40af57aa236dae733bac7035f4                          0.0s
 => [linux/arm64 final 2/3] WORKDIR /app                                                                           0.3s
 => [linux/amd64 final 2/3] WORKDIR /app                                                                           0.2s
 => [linux/amd64->arm64 build 2/8] WORKDIR /src                                                                    0.4s
 => [linux/amd64 build 3/8] RUN apt-get update     && apt-get install -y --no-install-recommends     clang zlib1  38.9s
 => [linux/amd64->arm64 build 3/8] RUN apt-get update     && apt-get install -y --no-install-recommends     cla  211.2s
 => [linux/amd64 build 4/8] COPY [test.csproj, .]                                                                  0.0s
 => [linux/amd64 build 5/8] RUN dotnet restore "./test.csproj"                                                     4.0s
 => [linux/amd64 build 6/8] COPY . .                                                                               0.0s
 => [linux/amd64 build 7/8] WORKDIR /src/.                                                                         0.0s
 => [linux/amd64 build 8/8] RUN dotnet build "./test.csproj" -c Release -a amd64 -o /app/build                     7.6s
 => [linux/amd64 publish 1/2] RUN if [ "amd64" = "arm64" ]; then ln -sf /usr/bin/aarch64-linux-gnu-objcopy /usr/l  0.2s
 => [linux/amd64 publish 2/2] RUN dotnet publish "./test.csproj" -c Release -a amd64 -o /app/publish /p:UseAppHo  19.5s
 => [linux/amd64 final 3/3] COPY --from=publish /app/publish .                                                     0.1s
 => [linux/amd64->arm64 build 4/8] COPY [test.csproj, .]                                                           0.1s
 => [linux/amd64->arm64 build 5/8] RUN dotnet restore "./test.csproj"                                              3.8s
 => [linux/amd64->arm64 build 6/8] COPY . .                                                                        0.1s
 => [linux/amd64->arm64 build 7/8] WORKDIR /src/.                                                                  0.0s
 => [linux/amd64->arm64 build 8/8] RUN dotnet build "./test.csproj" -c Release -a arm64 -o /app/build              8.8s
 => [linux/amd64->arm64 publish 1/2] RUN if [ "arm64" = "arm64" ]; then ln -sf /usr/bin/aarch64-linux-gnu-objcopy  0.3s
 => [linux/amd64->arm64 publish 2/2] RUN dotnet publish "./test.csproj" -c Release -a arm64 -o /app/publish /p:U  19.1s
 => [linux/arm64 final 3/3] COPY --from=publish /app/publish .                                                     0.1s
 => exporting to image                                                                                             1.0s
 => => exporting layers                                                                                            0.8s
 => => exporting manifest sha256:32e8341d99b7b23dd8f6b3c21a928012a81132fa9213994f2a5b499824b838c0                  0.0s
 => => exporting config sha256:74e4fe491bc324391b2b08e2c9401772b96d8dc0f79b46fa8beef4bf55d71f54                    0.0s
 => => exporting attestation manifest sha256:167bd3ee1f68e14edefa8b63ca65e373aac2f8ba589bb8b8f44812c6f22d36fb      0.0s
 => => exporting manifest sha256:3d054d4fbfd6ee4be57376561389339e0379ed33798311288f96c61612ee9217                  0.0s
 => => exporting config sha256:5795e8408dc1294fbf45f012bbe5e7a859dd9be5640231e9c1f16873bd99cf17                    0.0s
 => => exporting attestation manifest sha256:d1761acdadfde89e69451f265dad1bd51c21e67bdbae3806ad78db22a49c11f2      0.0s
 => => exporting manifest list sha256:3b7e5f49296d3b38fa075253ab918538974fee542a9f9b40648c165e04ffaaa7             0.0s
 => => naming to docker.io/library/test:latest                                                                     0.0s
 => => unpacking to docker.io/library/test:latest                                                                  0.1s
```

イメージのビルドが成功しました。これでx64/ARM64両対応したNativeAOTコンテナをビルドできるようになりました。
イメージの状態を見てみましょう。

```sh
$ docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
test         latest    6e2edcd22ece   39 seconds ago   289MB
```

Linuxビルドしてみると、NativeAOTアプリケーション自身は10MB程度 + デバッグシンボルで24MB程度なので、イメージサイズが289MBと大きいです。

```sh
$ ls -l ./bin/Release/net10.0/linux-x64/publish/
total 35444
-rwxrwxrwx 1 guitarrapc guitarrapc      127 Nov 23 01:21 appsettings.Development.json
-rwxrwxrwx 1 guitarrapc guitarrapc      151 Nov 23 01:21 appsettings.json
-rwxrwxrwx 1 guitarrapc guitarrapc 11086080 Nov 23 02:24 test
-rwxrwxrwx 1 guitarrapc guitarrapc 25206536 Nov 23 02:24 test.dbg
-rwxrwxrwx 1 guitarrapc guitarrapc       53 Nov 23 02:24 test.staticwebassets.endpoints.json
```

イメージサイズが250MB近いのは、ベースイメージに`mcr.microsoft.com/dotnet/runtime-deps:10.0`を使用しているためです。
NativeAOTアプリケーションはランタイムを必要としないこと、chiseldイメージでの動作に対応しているので、次のセクションでイメージサイズを削減しましょう。

## イメージサイズを削減する

`mcr.microsoft.com/dotnet/runtime-deps:10.0`は汎用的なランタイム非依存イメージであり、多くのライブラリが含まれています。このため、NativeAOTアプリケーションのコンテナイメージとしては大きすぎます。

[chiseledイメージ](https://learn.microsoft.com/en-us/dotnet/core/docker/container-images)を使用することで、イメージサイズを削減できます。chiseledイメージにはいくつか種類があります。

- `mcr.microsoft.com/dotnet/runtime-deps:10.0-chiseled`: CoreCLRのみ。tzdata、ICUは含まれない
- `mcr.microsoft.com/dotnet/runtime-deps:10.0-noble-chiseled-aot`: NativeAOT用のイメージ、tzdata、ICU、stdc++は含まれない
- `mcr.microsoft.com/dotnet/runtime-deps:10.0-noble-chiseled-extra`: CoreCLR, tzdata, ICU, stdc++が含まれる

NativeAOTであれば、日本語含むUnicodeやグローバリゼーション対応が不要なら`mcr.microsoft.com/dotnet/runtime-deps:10.0-noble-chiseled`、あるいはUnicodeやグローバリゼーション対応が必要なら`mcr.microsoft.com/dotnet/runtime-deps:10.0-noble-chiseled-extra`を使用するといいでしょう。

それぞれでベースイメージを置き換えて、マルチプラットフォームビルドを実行します。

```diff
# Unicode対応不要なら
- FROM ${FINAL_BASE_IMAGE:-mcr.microsoft.com/dotnet/runtime-deps:10.0} AS final
+ FROM ${FINAL_BASE_IMAGE:-mcr.microsoft.com/dotnet/runtime-deps:10.0-noble-chiseled} AS final

# Unicode対応必要なら
- FROM ${FINAL_BASE_IMAGE:-mcr.microsoft.com/dotnet/runtime-deps:10.0} AS final
+ FROM ${FINAL_BASE_IMAGE:-mcr.microsoft.com/dotnet/runtime-deps:10.0-noble-chiseled-extra} AS final
```

ベースイメージごとのイメージサイズは次の通りです。AOTアプリケーション自体のサイズは変わらないため、ベースイメージのサイズ差がそのままイメージサイズに反映されます。こうやって見ると、chiseledイメージはかなり小さいことが分かります。

| ベースイメージ | イメージサイズ |
| --- | --- |
| `mcr.microsoft.com/dotnet/runtime-deps:10.0` | 289MB |
| `mcr.microsoft.com/dotnet/runtime-deps:10.0-noble-chiseled` | 88.3MB |
| `mcr.microsoft.com/dotnet/runtime-deps:10.0-noble-chiseled-extra` | 160MB |

最も小さい`mcr.microsoft.com/dotnet/runtime-deps:10.0-noble-chiseled`ベースのイメージをコンテナ実行してみましょう。

```sh
$ docker run -it -p 8080:8080 test
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://[::]:8080
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Production
info: Microsoft.Hosting.Lifetime[0]
      Content root path: /app
```

期待通り結果が返ってきます。

```sh
$ url -i http://localhost:8080/todos
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Date: Sat, 22 Nov 2025 17:43:45 GMT
Server: Kestrel
Transfer-Encoding: chunked

[{"id":1,"title":"Walk the dog","dueBy":null,"isComplete":false},{"id":2,"title":"Do the dishes","dueBy":"2025-11-22","isComplete":false},{"id":3,"title":"Do the laundry","dueBy":"2025-11-23","isComplete":false},{"id":4,"title":"Clean the bathroom","dueBy":null,"isComplete":false},{"id":5,"title":"Clean the car","dueBy":"2025-11-24","isComplete":false}]
```

## まとめ

C#でWeb APIというと、どうしてもASP.NET CoreでJITランタイムを使うイメージが強いですが、NativeAOTを使うことでネイティブコード化も当然のように可能です。特にスタートアップ速度を求める環境やWASMを想定するなら、NativeAOTは非常に有用です。一方で、JITランタイムはPGOやDATASをはじめとする実行後も最適化をかける技術が進展しています。結果として、長時間稼働するサーバーアプリケーションではJITランタイムの方が実行速度[^1]高速になるケースもあります。

NativeAOTにする課題として、スタックとレースがネイティブコード由来になるためJITランタイムよりもデバッグが難しくなりえます。また、AOTコンパイル時にすべてのコードが解決されるため、リフレクションや動的コード生成を多用するアプリケーションでは対応が難しいですが、これはSource Generatorを活用するなど今後のスタンダードが変わっていくでしょう。

NativeAOTが最高、絶対これがいい、とすべてに対して言えるわけではありません。しかし、C#はJITランタイムだけでなくNativeAOTも選択肢として提供されており、すでに多くのシナリオで利用可能です。用途に応じてJITランタイムとNativeAOTを使い分けていきましょう。

[^1]: スタートアップ時間ではなく、それぞれの処理の実行速度を指す
