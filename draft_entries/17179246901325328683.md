---
Title: パイプ入力を使ってC#コードを実行したりスクリプト言語のように使う
Category:
- C#
- GitHubActions
Date: 2025-11-26T01:00:00+09:00
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/17179246901325328683
PreviewURL: https://tech.guitarrapc.com/draft/entry/5GoeGTsr0YZB0gtDbxZRHvXPMDs
CustomPath: 2025/11/26/010000
Draft: true
---

.NET 10から使えるC#のファイルベースプログラム実行機能を使うと、パイプ入力でC#コードを渡して実行できます。例えば、次のようなコマンドが実行できます。今回はこれの活用例を紹介します。

```sh
# BashやPowerShellで実行できる
$ echo 'Console.WriteLine("FooBar");' | dotnet run -
FooBar
```

[:contents]

## コンパイルを意識せず実行できる

C#はコンパイルが必要なため、いざ実行するとき、もっていくときに微妙にスクリプト的な使い心地を得られずにいました。.csxもあるのですが、標準C#と記法との違い、拡張子の違い、標準dotnet SDKだけで実行できないのが使いにく、デバッグも面倒です。

しかしファイルベースプログラムを使うとdotnet SDKのみ実行可能で.csxより取りまわしやすく、コードをファイルに保存せずそのまま実行できます。しかもいわゆるビルドコマンドを行わないのでコンパイルを意識せず、それでいて実行前にコンパイルによる安全性が担保されます。

```sh
$ echo 'int x = "string";' | dotnet run -
C:\Users\guitarrapc\AppData\Local\Temp\dotnet\runfile\1ohbfytn.dex\app.cs(1,9): error CS0029: Cannot implicitly convert type 'string' to 'int'

The build failed. Fix the build errors and run again.
```

型エラーや構文エラーがあれば実行前に検出できるというのは、かなり安心感があるでしょう。スクリプト的な使い心地とコンパイル言語の安全性を両立できるのが強みです。

## パイプ入力を使ってちょっとした処理を実行する

ちょっと1-10でランダムな順番の数列を生成したいときも、`Enumerable.Range`と`Shuffle`で簡単に実行できます。

```sh
$ echo 'Console.WriteLine(string.Join(",", Enumerable.Range(1,10).Shuffle().ToArray()));' | dotnet run -
9,3,1,8,10,4,5,2,7,6
```

あるいは、Webページの最初の10行を取得したいときも、`HttpClient`を使って簡単に実行できます。複数行コードもパイプで渡せるので、いわゆるPythonやBashスクリプトのように使えます。かき捨てですばやく実行したいときに便利です。

```sh
$ cat <<EOF | dotnet run -
using System.Net.Http;
var client = new HttpClient();
var res = await client.GetStringAsync("https://tech.guitarrapc.com");
var first10 = res.Split("\n").Take(10);
Console.WriteLine(string.Join("\n", first10));
EOF
<!DOCTYPE html>
<html
  lang="ja"

data-admin-domain="//blog.hatena.ne.jp"
data-admin-origin="https://blog.hatena.ne.jp"
data-author="guitarrapc_tech"
data-avail-langs="ja en"
data-blog="guitarrapc-tech.hatenablog.com"
data-blog-host="guitarrapc-tech.hatenablog.com"
```

## GitHub Actionsでスクリプト代わりに実行する

こういうスクリプト的な書き捨ては、GitHub ActionsのワークフローYAMLで実行するときに便利です。賛否あるものの、GitHub Actionsでちょっとした処理を実行したいときにBash/Python/Rubyスクリプトをインラインで書くことがあります。

例えば、[hadashiAVContainer](https://github.com/hadashiA/VContainer)のGitHub Actionsワークフローでは、Rubyスクリプトを使ってファイルのバージョンを更新しています。

```yaml
jobs:
  update-version-number:
    steps:
      - name: Update version number ${{ steps.configure.outputs.git-tag }}
        run: |
          ruby .github/update_version_number.rb ${{ steps.configure.outputs.git-tag }}
```

Rubyの中身は次のようになっています。シンプルでいいです。

```ruby
V = ARGV[0]
working_dir = File.expand_path(File.dirname(File.dirname(__FILE__)))

def replace_install_url(src)
  src.gsub(
    %r{(https://github.com/hadashiA/VContainer.git\?path=VContainer/Assets/VContainer#)[\d\.]+},
    %Q{\\1#{V}}
  )
end

def replace_package_json(src)
  src.gsub(
    /"version"\s*:\s*"([\d\.]+)"/,
    %Q{"version": "#{V}"})
end

def replace_docusaurus_config(src)
  src.gsub(
    /label\s*:\s*['"]v?[\d\.]+['"]/,
    %Q{'label': 'v#{V}'})
end

{
  replace_package_json: ["VContainer/Assets/VContainer/package.json"],
  replace_install_url: ["README.md", "website/docs/getting-started/installation.mdx", "website/i18n/ja/docusaurus-plugin-content-docs/current/getting-started/installation.mdx"],
  replace_docusaurus_config: ["website/docusaurus.config.ts"]
}.each do |method, relative_paths|
  relative_paths.each do |relative_path|
    path = File.join(working_dir, relative_path)
    src = File.read path
    dst = send(method, src)
    File.write path, dst
  end
end
```

C#のファイルベースプログラムなら、これと近い雰囲気で書くことができます。C#版を用意しましたが、Ruby版と良く似ておりかなり近いため好みの言語で書けるといってもいいでしょう。これはClaudeに指示をして、RubyをベースにC#版を書かせてから軽く調整していますが、ほぼ手間がかかっていません。

```cs
using System.Text.RegularExpressions;
var v = args[0];
var workingDir = Path.GetDirectoryName(Directory.GetCurrentDirectory())!;

string ReplaceInstallUrl(string src) => Regex.Replace(
    src,
    @"(https://github.com/hadashiA/VContainer.git\?path=VContainer/Assets/VContainer#)[\d\.]+",
    m => $"{m.Groups[1].Value}{v}"
);

string ReplacePackageJson(string src) => Regex.Replace(
    src,
    "\"version\"\\s*:\\s*\"[\\d\\.]+\"",
    $"\"version\": \"{v}\""
);

string ReplaceDocusaurusConfig(string src) => Regex.Replace(
    src,
    @"label\s*:\s*['""]v?[\d\.]+['""]",
    $"'label': 'v{v}'"
);

var jobs = new (Func<string, string> Replacer, string[] RelativePaths)[]
{
    (ReplacePackageJson,["VContainer/Assets/VContainer/package.json"]),
    (ReplaceInstallUrl,["README.md", "website/docs/getting-started/installation.mdx", "website/i18n/ja/docusaurus-plugin-content-docs/current/getting-started/installation.mdx"]),
    (ReplaceDocusaurusConfig,["website/docusaurus.config.ts"]),
};

foreach (var (replacer, relativePaths) in jobs)
{
    foreach (var relativePath in relativePaths)
    {
        var path = Path.Combine(workingDir, relativePath);
        if (!File.Exists(path))
        {
            Console.Error.WriteLine($"Skip (not found): {path}");
            continue;
        }
        var src = File.ReadAllText(path);
        var dst = replacer(src);
        if (src.Equals(dst, StringComparison.Ordinal))
        {
            Console.WriteLine($"No changes: {path}");
            continue;
        }
        File.WriteAllText(path, dst);
        Console.WriteLine($"Updated: {path}");
    }
}
```

GitHub Actionsワークフローも、次のようにC#コードを実行できます。

```yaml
jobs:
  update-version-number:
    steps:
      - name: Update version number ${{ steps.configure.outputs.git-tag }}
        run: |
          dotnet .github/update_version_number.cs -- ${{ steps.configure.outputs.git-tag }}
```

実行すると次のようなログが出ます。

```sh
$ dotnet run .github/update_version_number.cs -- 1.1.1
Updated: VContainer-master/VContainer-master/VContainer/Assets/VContainer/package.json
Updated: VContainer-master/VContainer-master/README.md
Updated: VContainer-master/VContainer-master/website/docs/getting-started/installation.mdx
Updated: VContainer-master/VContainer-master/website/i18n/ja/docusaurus-plugin-content-docs/current/getting-started/installation.mdx
No changes: VContainer-master/VContainer-master/website/docusaurus.config.ts
```

他にも、コマンド実行も[Cysharp/ProcessX](https://github.com/Cysharp/ProcessX)でZxを使ってもいいでしょう。

## まとめ

C#のファイルベースプログラムって、.csファイルを用意して実行することを考えがちでしたが、そういえばパイプ入力でコードを渡して実行できます。あまり頻繁には使わないでしょうが、ちょっとしたスクリプト的な処理を実行したいときに便利です。

これまでより、GitHub Actionsのワークフローのちょっとした処理を実行したいときにも使えますね。
