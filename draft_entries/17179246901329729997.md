---
Title: External Secrets OperatorからAWS Secrets Store CSI Driver providerに切り替える
Category:
- Kubernetes
- AWS
Date: 2025-12-08T17:00:00+09:00
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/17179246901329729997
PreviewURL: https://tech.guitarrapc.com/draft/entry/kwMick-7H7PvnbPLBWMXaxZRk-s
CustomPath: 2025/12/08/170000
Draft: true
---

先日、EKS AddonにAWS Secrets Store CSI Driver providerを追加したという[アナウンス](https://aws.amazon.com/jp/about-aws/whats-new/2025/11/amazon-eks-add-ons-aws-secrets-store-csi-driver-provider/)がありました。これにより、Kubernetesで外部シークレット管理サービスを利用する方法として、External Secrets Operator(ESO)からSecrets Store CSI Driverへ切り替える選択肢が現実的になりました。

今回は、ESOの現状を踏まえつつ、AWS Secrets Store CSI Driver providerでのシークレット管理方法についてみていきます。

[:contents]

## Kubernetesにおけるシークレット管理の背景

Kubernetesにおいて、どうしよう...となりやすいのがシークレットです。Kubernetes SecretsはただのBase64エンコードされた平文データなため、KuberentesマニフェストとしてGitリポジトリに保存するのは現代のポリシー的には受け入れられません。かといってシークレットをKNSや公開鍵で暗号化してGitに保存すると、機密情報のアップデートや利用がとても煩雑になります。使いやすさとセキュリティのバランスを取るのが難しいわけです。

そこで、ここ数年はクラウドの機密情報ストア(AWS Secrets Manager, Azure Key Vaultなど)にデータを保持しておき、Kubernetesはそれを読み取ってKubernetes SecretsやPodにマウントする手法が広く利用されています。この方法なら、Gitやコンテナに直接シークレットを含めることなく安全にPodに提供できるわけです。そんな機密情報ストアをKubernetesから利用する方法として、コミュニティが提供しているコントローラーのExternal Secrets Operator(ESO)、Kubernetes公式のSecrets Store CSI Driverを各種クラウドごとに実装したものがあります。

### External Secrets Operatorとは

[External Secrets Operator](https://github.com/external-secrets/external-secrets)は、機密情報ストアからシークレットを取得しKubernetes Secretsへ動機/提供するオープンソースのコントローラーです。ESOはクラウドを含む複数のシークレット管理サービスに対応しており、柔軟な認証方式をサポートしています。また、ESO以前に使われていた同様の機能を提供していたコントローラー`Kubernetes External Secrets`から移行先として提示されたこともあり、現在も広く利用されています。

そんなESOですが、2025年、プロジェクトの利用者に対してコア開発者の少なさが課題となっていることがアナウンスされています。いわゆるOSSで食っていけない状況が続いています。

- 2022年11月3日、GoDaddy提供の[kubernetes-extenal-secrets](https://github.com/external-secrets/kubernetes-external-secrets)[^1]がメンテナンスされなくなり、同時期に登場した[External Secrets Operator](https://github.com/external-secrets/external-secrets)への移行をユーザーに[アナウンス](https://github.com/external-secrets/kubernetes-external-secrets/issues/864)
- 2025年8月13日、ユーザーの大きさに対してコアチームの人数不足の現状から、最低5人の長期コミュニティメンバーが揃うまでリリースを一時停止する[アナウンス](https://github.com/external-secrets/external-secrets/pull/5137)
- 2025年9月12日、リリースの一時停止に関する[アナウンスが削除](https://github.com/external-secrets/external-secrets/pull/5309)し、リリースが再開

ESOの状況に対して私個人としてできるのはコントリビュートやスポンサーですが、他方でリリースが止まった状況を踏まえると今後の代替手段を探す必要もあります。

### Secrets Store CSI Driverとは

Secrets Store CSI Driverの前にCSIについて簡単に説明します。KubernetesのContainer Storage Interface(CSI) Driverは、永続ストレージ(ブロックデバイスやファイルストレージ)をプラグイン方式で追加できるようにする仕組みです。実装例として`AWS EBS CSI Driver`、`Azure Disk CSI Driver`、`Google Compute Engine Persistent Disk CSI Driver`などがありストレージ(`PV/PVC`)を提供します。

一方で、`Secrets Store CSI Driver`はストレージではなく外部の機密情報ストアに保存された機密情報をCSIボリューム[^2]としてPodにマウントするためのドライバーです。AWSが公式に提供する[AWS Secrets Store CSI Driver provider](https://github.com/aws/secrets-store-csi-driver-provider-aws)(AWS Secrets and Configuration Provioderとも呼ばれる)はその実装例の1つで、AWS Secrets ManagerやAWS Systems Manager Parameter Storeに保存されているシークレットをPod内のファイルとしてマウントしたり、オプションでKubernetes Secretへ同期できます。

`AWS Secrets Store CSI Driver provider`(ASCP)はESOと同じような使い方ができますが、EKS実装にもかかわらずHelm Chartで導入する必要があり、あまり機能が変わらないためESOを使っているなら、移行するほどの動機付けもありませんでした。しかし今回、EKS AddonにASCPが[加わった](https://aws.amazon.com/jp/about-aws/whats-new/2025/11/amazon-eks-add-ons-aws-secrets-store-csi-driver-provider/)ことで、導入や運用が以前より簡単になりました。何よりESOのメンテナンス問題を考えると、AWS公式がメンテナンスしている点は魅力的です。ここにきて、ESOの代替手段として十分に検討できるようになりました。

## EKS AddonでAWS Secrets Store CSI Driver providerをインストール

ASCPは、AWS提供のEKS Addonとして導入できます。EKS Addonを利用することで、Helm Chartやマニフェストを手動で適用する必要がなくなり、AWS Management ConsoleやAWS CLIから簡単に導入できます。AWS提供のEKS Addonなので、EKSクラスターのバージョンアップに合わせて速やかにバージョンアップが提供される点もメリットです。[^3]

EKS Addonとして導入する場合、以下のコマンドでAddonをインストールします。どの方法もHelmチャートを使ってインストールするより圧倒的に簡単です。カスタム設定したい値が、`syncSecret.enabled: bool`程度しかないので現実的にありって感じです。

```sh
eksctl create addon --cluster $CLUSTER_NAME --name aws-secrets-store-csi-driver-provider
```

あるいは、IaCなら次のように設定します。TerraformとPulumi C#の例を示します。

```terraform
# terraform
resource "aws_eks_addon" "aws_secrets_store_csi_driver_provider" {
  cluster_name                = aws_eks_cluster.example.name
  addon_name                  = "aws-secrets-store-csi-driver-provider"
  addon_version               = "v2.1.1-eksbuild.1"
  resolve_conflicts_on_update = "OVERWRITE",
  resolve_conflicts_on_create = "OVERWRITE",
  configuration_values        = jsonencode({
    "secrets-store-csi-driver" = {
      "syncSecret" = {
        "enabled" = true
      }
    }
  })
}
```

```cs
// Pulumi C#
new Addon($"{name}-aws-secrets-store-csi-driver-provider", new()
{
    AddonName = "aws-secrets-store-csi-driver-provider",
    AddonVersion = "v2.1.1-eksbuild.1",
    ClusterName = cluster.Name,
    ResolveConflictsOnCreate = "OVERWRITE",
    ResolveConflictsOnUpdate = "OVERWRITE",
    ConfigurationValues = """
    {
        "secrets-store-csi-driver": {
            "syncSecret": {
                "enabled": true
            }
        }
    }
    """.Minify(),
});

static string Minify(this string value) => value
    .Replace("\r\n", "\n")
    .Replace("\n", "")
    .Replace("\t", "")
    .Replace(" ", "");
```

利用できるEKS Addonバージョンは、次のコマンドで確認できます。

```sh
aws eks describe-addon-versions --kubernetes-version 1.34 --addon-name aws-secrets-store-csi-driver-provider | jq ".addons[].addonVersions[] | {addonVersion: .addonVersion, clusterVersion: .compatibilities[0].clusterVersion }"
```

### Pod Identityの用意

ESOはESO ControllerでAWS認証しましたが、ASCPは利用するアプリケーションPodのService AccountでAWS認証します。Podごとに異なる権限を与えられるので、より細かい権限管理が可能です。Pod Identityを利用する場合、[EKS Pod Identity](https://docs.aws.amazon.com/ja_jp/systems-manager/latest/userguide/ascp-pod-identity-integration.html)を設定します。AssumeRoleポリシーは、次のように設定します。

```json
{
    "Version":"2012-10-17",
    "Statement": [
      {
        "Effect": "Allow",
        "Principal": {
          "Service": "pods.eks.amazonaws.com"
        },
        "Action": [
          "sts:AssumeRole",
          "sts:TagSession"
        ]
      }
    ]
  }
```

Pulumi C#での設定例は次の通りです。defaault namespaceで、test-appというService AccountをPod Identityに紐づける場合の例です。今回はSSM Parameter Storeからシークレットを取得するので、`AWSSecretsManagerClientReadOnlyAccess`と`AmazonSSMReadOnlyAccess`を付与しています。必要に応じてポリシーをカスタマイズしてください。


```cs
// Pulumi C#
var test = new IamRoleComponent($"{name}-test-app", new () { Parent = this }, new()
{
    AssumeRolePolicy = IamPolicy.GetAssumeRolePolicyJson("pods.eks.amazonaws.com", ["sts:TagSession"]),
    IamPolicyArg = new IamPolicyArg
    {
        PolicyArns = IamPolicy.GetAwsManagedPolicyArns(
        [
            // AWS Secrets Store CSI Driver
            "arn:aws:iam::aws:policy/AWSSecretsManagerClientReadOnlyAccess",
            "arn:aws:iam::aws:policy/AmazonSSMReadOnlyAccess",
        ]),
    },
    RoleName = $"{name}-test-app",
});
foreach (var item in new[] { new NamespaceServiceAccountMapping("default", "test-app") })
{
    new PodIdentityAssociation($"{name}-podidentity-assoc-test-app-{item.Namespace}-{item.ServiceAccount}", new()
    {
        ClusterName = cluster.Name,
        RoleArn = test.Role.Arn,
        Namespace = item.Namespace,
        ServiceAccount = item.ServiceAccount,
        DisableSessionTags = false,
    });
}

private record NamespaceServiceAccountMapping(string Namespace, string ServiceAccount);
```

SSM Parameter Storeに次のようなシークレットを用意しておきます。

```yaml
foobar: "foobar-value"
piyopiyo: "1234567"
```

これで準備は整いました。AWS provider for the Secrets Store CSI Driverは、DaemonSetとして各ノードにデプロイされているので、PodからSSM Parameter Storeへアクセスできるようになります。

## AWS Secrets Store CSI Driver providerを利用する

ASCPの基本的な使い方は2つ。1はESOではできなかったパターン、2はESOのパターンです。

1. シークレットをPodのボリュームへ直接マウントするパターン
2. シークレットをKubernetes Secretとして同期しPodからKubernetes Secretを参照するパターン

Secret同期のSecretProviderClass定義はこういう感じです。

```yaml
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: test-app-secretstore
  namespace: default
spec:
  provider: aws
  # 1のパターン (2でもこれは必須)
  parameters:
    objects: |
      - objectName: "piyopiyo"
        objectType: "ssmparameter"
      - objectName: "foobar"
        objectType: "ssmparameter"
        objectAlias: "my-parameter"
    usePodIdentity: "true"
  # 2のパターンが必要なら以下を足す
  secretObjects:
    - secretName: test-app-secret
      type: Opaque
      data:
        - objectName: "piyopiyo"
          key: "PIYO"
        - objectName: "my-parameter"
          key: "PARAMETER"
```

順にみてみましょう。

### Podのボリュームへ直接マウントするパターン

ボリュームマウントパターン (SecretProviderClassでsecretsObjectsを定義しない場合) は、次のような特徴があります。

- Podのボリュームとしてシークレットのマウントパスを指定する
- External Secrets Operatorと違って、Kubernetes Secretが生成されない

シークレットと同期するためにSecretProviderClassを用意します。シークレットの同期設定は`spec.parameters`に定義します。`provider: aws`を指定し、どのように同期するか設定します。

- `usePodIdentity: true`: Pod Identityを利用してAWS認証[^4]
- `objectType: ssmparamter`: SSM Parameter Storeからシークレットを取得
- `objectName: string`: 取得するシークレット名を指定
- `objectAlias: string`: マウント時のファイル名を変更可能です(省略可能)

```yaml
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: test-app-secretstore
  namespace: default
spec:
  provider: aws
  parameters:
    objects: |
      - objectName: "piyopiyo"
        objectType: "ssmparameter"
      - objectName: "foobar"
        objectType: "ssmparameter"
        objectAlias: "my-parameter"
    usePodIdentity: "true"
```

次にDeploymentを定義します。Podのボリュームとして、Secrets Store CSI Driverのボリュームをマウントすることを頭に入れておきましょう。また、PodIdentityで紐づけたService Accountを指定することで、Pod起動時にSSM Parameter Storeへアクセス認証され、Podがボリュームマウント、起動します。

```yaml
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: test-app
  namespace: default
---
kind: Service
apiVersion: v1
metadata:
  name: test-app-svc
  namespace: default
  labels:
    app: test-app
spec:
  selector:
    app: test-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-app
  namespace: default
  labels:
    app: test-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: test-app
  template:
    metadata:
      labels:
        app: test-app
    spec:
      serviceAccountName: test-app
      containers:
        - name: nginx
          image: nginx:latest
          ports:
            - containerPort: 80
              name: http
          resources:
            limits:
              memory: "128Mi"
              cpu: "250m"
            requests:
              memory: "128Mi"
              cpu: "250m"
          volumeMounts:
            - name: secrets-store-inline
              mountPath: "/mnt/secrets-store"
              readOnly: true
      volumes:
        - name: secrets-store-inline
          csi:
            driver: secrets-store.csi.k8s.io
            readOnly: true
            volumeAttributes:
              secretProviderClass: "test-app-secretstore"
```

デプロイして、PodとSecretの状態を確認します。ESOと違ってSecretは生成されていないことがわかります。また、volumeにSecrets Store CSI Driverのボリュームがマウントされていることがわかります。

```sh
$ kubectl get po
kNAME                        READY   STATUS    RESTARTS   AGE
test-app-5989fbd45f-rzk2d   1/1     Running   0          3m38s
$ kubectl get secret
No resources found in default namespace.
$ kubectl get po test-app-5989fbd45f-rzk2d -o yaml | kubectl neat
apiVersion: v1
kind: Pod
metadata:
  labels:
    app: test-app
    pod-template-hash: 5c74d5fd8b
  name: test-app-5989fbd45f-rzk2d
  namespace: default
spec:
  containers:
  - env:
    - name: AWS_STS_REGIONAL_ENDPOINTS
      value: regional
    - name: AWS_DEFAULT_REGION
      value: ap-northeast-1
    - name: AWS_REGION
      value: ap-northeast-1
    - name: AWS_CONTAINER_CREDENTIALS_FULL_URI
      value: http://169.254.170.23/v1/credentials
    - name: AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE
      value: /var/run/secrets/pods.eks.amazonaws.com/serviceaccount/eks-pod-identity-token
    image: nginx:latest
    name: nginx
    ports:
    - containerPort: 80
      name: http
    resources:
      limits:
        cpu: 250m
        memory: 128Mi
    volumeMounts:
    - mountPath: /mnt/secrets-store
      name: secrets-store-inline
      readOnly: true
    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
      name: kube-api-access-kwk52
      readOnly: true
    - mountPath: /var/run/secrets/pods.eks.amazonaws.com/serviceaccount
      name: eks-pod-identity-token
      readOnly: true
  preemptionPolicy: PreemptLowerPriority
  priority: 0
  serviceAccountName: test-app
  tolerations:
  - effect: NoExecute
    key: node.kubernetes.io/not-ready
    operator: Exists
    tolerationSeconds: 300
  - effect: NoExecute
    key: node.kubernetes.io/unreachable
    operator: Exists
    tolerationSeconds: 300
  volumes:
  - name: eks-pod-identity-token
    projected:
      sources:
      - serviceAccountToken:
          audience: pods.eks.amazonaws.com
          expirationSeconds: 81586
          path: eks-pod-identity-token
  - csi:
      driver: secrets-store.csi.k8s.io
      readOnly: true
      volumeAttributes:
        secretProviderClass: test-app-secretstore
    name: secrets-store-inline
  - name: kube-api-access-kwk52
    projected:
      sources:
      - serviceAccountToken:
          expirationSeconds: 3607
          path: token
      - configMap:
          items:
          - key: ca.crt
            path: ca.crt
          name: kube-root-ca.crt
      - downwardAPI:
          items:
          - fieldRef:
              fieldPath: metadata.namespace
            path: namespace
```

Podにマウントされたボリュームを確認して、期待通りシークレットが取得できていることを確認しましょう。

```sh
$ kubectl exec -it test-app-5989fbd45f-rzk2d  -- /bin/bash
root@test-app-5989fbd45f-rzk2d:/# ls /mnt/secrets-store/
my-parameter  piyopiyo
root@test-app-5989fbd45f-rzk2d:/# cat /mnt/secrets-store/my-parameter
foobar-value
root@test-app-5989fbd45f-rzk2d:/# cat /mnt/secrets-store/piyopiyo
1234567
```

いい感じですね。

ESOと違って、Kubernetes Secretを生成しない分、攻撃対象領域が減るのでセキュリティ的にも良いです。
一方で、何か設定ミスでPodが起動してこない状況になった時は原因を特定しづらい点に注意です。Secretsが生成されるならSecretsの状態を見ることで原因を特定しやすいですが、Secretsが生成されない場合、Podのログやイベントから原因を特定する必要があります。

### Kubernetes Secretへ同期するパターン

シークレット生成パターン (SecretProviderClassでsecretsObjectsを定義する場合) は、次のような特徴があります。

- External Secrets Operatorと同様に、Kubernetes Secretが生成される

Kubernetes Secretesとシークレットと同期するためにSecretProviderClassを用意します。シークレットの同期設定は`spec.parameters`に定義ですが、これに加えて、`secretObjects`にKubernetes Secretの定義を追加します。`provider: aws`を指定し、どのように同期するか設定します。

- `secretName: string`: 生成するKubernetes Secret名を指定
- `type: string`: 生成するKubernetes Secretのタイプを指定
- `data: []`: 生成するKubernetes Secretのデータを指定。`objectName`でSecrets Store CSI Driverから取得するシークレット名を指定し、`key`でKubernetes Secret内でのキー名を指定

この時、`parameters.objects[].objectAlias`でエイリアス指定している場合は、`secretObjects[].data.objectName`にもエイリアス名を指定する必要があります。

```yaml
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: test-app-secretstore
  namespace: default
spec:
  provider: aws
  parameters:
    objects: |
      - objectName: "piyopiyo"
        objectType: "ssmparameter"
      - objectName: "foobar"
        objectType: "ssmparameter"
        objectAlias: "my-parameter"
    usePodIdentity: "true"
  secretObjects:
    - secretName: test-app-secret
      type: Opaque
      data:
        - objectName: "piyopiyo"
          key: "PIYO"
        - objectName: "my-parameter"
          key: "PARAMETER"
```

次にDeploymentを定義します。先ほどとの違いとして、Podのボリュームマウントは不要、Podからは生成されたKubernetes Secretを参照します。今回はわかりやすいように、`env`でKubernetes Secretを個別に参照しています。

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-app
  namespace: default
  labels:
    app: test-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: test-app
  template:
    metadata:
      labels:
        app: test-app
    spec:
      serviceAccountName: test-app
      containers:
        - name: nginx
          image: nginx:latest
          ports:
            - containerPort: 80
              name: http
          resources:
            limits:
              memory: "128Mi"
              cpu: "250m"
            requests:
              memory: "128Mi"
              cpu: "250m"
          volumeMounts:
            - name: secrets-store-inline
              mountPath: "/mnt/secrets-store"
              readOnly: true
          env:
            - name: PIYO
              valueFrom:
                secretKeyRef:
                  name: test-app-secret
                  key: PIYO
            - name: PARAMETER
              valueFrom:
                secretKeyRef:
                  name: test-app-secret
                  key: PARAMETER
      volumes:
        - name: secrets-store-inline
          csi:
            driver: secrets-store.csi.k8s.io
            readOnly: true
            volumeAttributes:
              secretProviderClass: "test-app-secretstore"
```

デプロイして、PodとSecretの状態を確認します。ESOと同様に、Secretが生成されていることがわかります。また、PodのenvがKubernetes Secretを参照していることがわかります。

```sh
$ kubectl get secret
NAME              TYPE     DATA   AGE
test-app-secret   Opaque   2      3m51s

$ kubectl get po
NAME                        READY   STATUS    RESTARTS   AGE
test-app-5c74d5fd8b-g2q9c   1/1     Running   0          5m11s

$ kubectl get po test-app-5c74d5fd8b-g2q9c -o yaml | kubectl neat
apiVersion: v1
kind: Pod
metadata:
  labels:
    app: test-app
    pod-template-hash: 5c74d5fd8b
  name: test-app-5c74d5fd8b-g2q9c
  namespace: default
spec:
  containers:
  - env:
    - name: PIYO
      valueFrom:
        secretKeyRef:
          key: PIYO
          name: test-app-secret
    - name: PARAMETER
      valueFrom:
        secretKeyRef:
          key: PARAMETER
          name: test-app-secret
    - name: AWS_STS_REGIONAL_ENDPOINTS
      value: regional
    - name: AWS_DEFAULT_REGION
      value: ap-northeast-1
    - name: AWS_REGION
      value: ap-northeast-1
    - name: AWS_CONTAINER_CREDENTIALS_FULL_URI
      value: http://169.254.170.23/v1/credentials
    - name: AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE
      value: /var/run/secrets/pods.eks.amazonaws.com/serviceaccount/eks-pod-identity-token
    image: nginx:latest
    name: nginx
    ports:
    - containerPort: 80
      name: http
    resources:
      limits:
        cpu: 250m
        memory: 128Mi
    volumeMounts:
    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
      name: kube-api-access-kwk52
      readOnly: true
    - mountPath: /var/run/secrets/pods.eks.amazonaws.com/serviceaccount
      name: eks-pod-identity-token
      readOnly: true
  preemptionPolicy: PreemptLowerPriority
  priority: 0
  serviceAccountName: test-app
  tolerations:
  - effect: NoExecute
    key: node.kubernetes.io/not-ready
    operator: Exists
    tolerationSeconds: 300
  - effect: NoExecute
    key: node.kubernetes.io/unreachable
    operator: Exists
    tolerationSeconds: 300
  volumes:
  - name: eks-pod-identity-token
    projected:
      sources:
      - serviceAccountToken:
          audience: pods.eks.amazonaws.com
          expirationSeconds: 81586
          path: eks-pod-identity-token
  - name: kube-api-access-kwk52
    projected:
      sources:
      - serviceAccountToken:
          expirationSeconds: 3607
          path: token
      - configMap:
          items:
          - key: ca.crt
            path: ca.crt
          name: kube-root-ca.crt
      - downwardAPI:
          items:
          - fieldRef:
              fieldPath: metadata.namespace
            path: namespace
```

Podのenvを確認して、期待通りシークレットが取得できていることを確認しましょう。

```sh
$ kubectl exec -it test-app-5c74d5fd8b-g2q9c -- /bin/bash
root@test-app-5c74d5fd8b-g2q9c:/# env | grep PIYO
PIYO=1234567
root@test-app-5c74d5fd8b-g2q9c:/# env | grep PARAMETER
PARAMETER=foobar-value
```

いい感じですね。ESO同様にKubernetes Secretを生成するので、ESOからの移行もスムーズに行えます。

## TIPS: Secrets同期されずエラーが出るとき

デフォルトのEKS Addon構成だと、Secretsを作成するオプション`syncSecret: false`がデフォルトであるため、Secretsを生成できません。
この場合、Secrets APIにアクセスできないことがログでわかります。

```sh
$ stern secrets-store-csi-driver
secrets-store-csi-driver-pqpxz secrets-store I1203 07:17:15.486011       1 reflector.go:424]"pkg/mod/k8s.io/client-go@v0.26.4/tools/cache/reflector.go:169: failed to list *v1.Secret: secrets is forbidden: User \"system:serviceaccount:aws-secrets-manager:secrets-store-csi-driver\" cannot list resource \"secrets\" in API group \"\" at the cluster scope\n"
secrets-store-csi-driver-pqpxz secrets-store E1203 07:17:15.486080       1 reflector.go:140]"pkg/mod/k8s.io/client-go@v0.26.4/tools/cache/reflector.go:169: Failed to watch *v1.Secret: failed to list *v1.Secret: secrets is forbidden: User \"system:serviceaccount:aws-secrets-manager:secrets-store-csi-driver\" cannot list resource \"secrets\" in API group \"\" at the cluster scope\n"
```

原因は、CSIが利用するClusterRoleに権限がついていないためです。

```sh
$ kubectl get clusterrole aws-secrets-store-csi-driver-provider-cluster-role -o yaml  | kubectl neat
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    app: aws-secrets-store-csi-driver-provider
    app.kubernetes.io/instance: aws-secrets-store-csi-driver-provider
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: aws-secrets-store-csi-driver-provider
    helm.sh/chart: aws-secrets-store-csi-driver-provider-2.1.1
  name: aws-secrets-store-csi-driver-provider-cluster-role
rules:
- apiGroups:
  - ""
  resources:
  - serviceaccounts/token
  verbs:
  - create
- apiGroups:
  - ""
  resources:
  - serviceaccounts
  verbs:
  - get
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
- apiGroups:
  - ""
  resources:
  - nodes
  verbs:
  - get

$ kubectl get clusterrole secretproviderclasses-role -o yaml | kubectl neat
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    app: secrets-store-csi-driver
    app.kubernetes.io/instance: aws-secrets-store-csi-driver-provider
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: secrets-store-csi-driver
    app.kubernetes.io/version: 1.5.4
    helm.sh/chart: secrets-store-csi-driver-1.5.4
  name: secretproviderclasses-role
rules:
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - secrets-store.csi.x-k8s.io
  resources:
  - secretproviderclasses
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - secrets-store.csi.x-k8s.io
  resources:
  - secretproviderclasspodstatuses
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - secrets-store.csi.x-k8s.io
  resources:
  - secretproviderclasspodstatuses/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - storage.k8s.io
  resourceNames:
  - secrets-store.csi.k8s.io
  resources:
  - csidrivers
  verbs:
  - get
  - list
  - watch
```

対応方法は簡単で、EKS Addonに定義をsyncSecret追加します。

```json
{"secrets-store-csi-driver":{"syncSecret":{"enabled":true}}}
```

[f:id:guitarrapc_tech:20251208175725p:plain:alt=alt text]

[f:id:guitarrapc_tech:20251208175732p:plain:alt=alt text]

これで、同期用のClusterRoleが作成、ClusterRoleBindingsが作成されます。

```sh
$ kubectl get clusterrole secretprovidersyncing-role -o yaml | kubectl neat
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    app: secrets-store-csi-driver
    app.kubernetes.io/instance: aws-secrets-store-csi-driver-provider
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: secrets-store-csi-driver
    app.kubernetes.io/version: 1.5.4
    helm.sh/chart: secrets-store-csi-driver-1.5.4
  name: secretprovidersyncing-role
rules:
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch

$ kubectl get clusterrolebinding secretprovidersyncing-rolebinding -o yaml | kubectl neat
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    app: secrets-store-csi-driver
    app.kubernetes.io/instance: aws-secrets-store-csi-driver-provider
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: secrets-store-csi-driver
    app.kubernetes.io/version: 1.5.4
    helm.sh/chart: secrets-store-csi-driver-1.5.4
  name: secretprovidersyncing-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: secretprovidersyncing-role
subjects:
- kind: ServiceAccount
  name: secrets-store-csi-driver
  namespace: aws-secrets-manager
```

[f:id:guitarrapc_tech:20251208175740p:plain:alt=alt text]


Secretsも生成されるようになります。

## まとめ

EKS Addonになったことで、Helmで導入するよりこっちのほうがいい感じです。導入、運用がここまで楽なら、ESOからの移行も十分に検討できるレベルになりました。変に抽象化せず、awsならaws用のSecrets CSI Driver、Google Cloudなら、Azureなら... と個別のクラウド別に別リポジトリで管理されているのも好印象です。

EKS Addonで導入時は以下の追加コンフィグだけ設定すれば、OSS helm版やExternal Secrets Operatorでやりたいパターンが網羅できます。

```json
{"secrets-store-csi-driver":{"syncSecret":{"enabled":true}}}
```

認証はPod IdentityとIRSAの両方に対応しているので、namespaceが決め打ちできるコントローラー系はPod IdentityでOK。ブランチ環境とかB/Gなどでnamespaceが固定できないアプリはIRSAで認証すればOK。
懸念は、コントローラー認証ではなくクライアント認証になるので、APIレートリミットに引っかかりやすくはなりそうです。

ESOからの移行が現実的にできそうなので、オススメって感じでした。

また、AWS的にはセキュアのシナリオでは、[AWS Secrets Manager Agent](https://docs.aws.amazon.com/secretsmanager/latest/userguide/secrets-manager-agent.html)から取得してインメモリに保持しろというのは[公式見解](https://aws.amazon.com/jp/blogs/security/how-to-use-the-secrets-store-csi-driver-provider-amazon-eks-add-on-with-secrets-manager/)としてあるようです。

> Security best practice recommends caching secrets in memory where possible. If you prefer to adopt the native Kubernetes experience, please follow the steps in this blog post. If you prefer to cache secrets in memory, we recommend using the AWS Secrets Manager Agent.

## 参考資料

- [Amazon EKS add-ons now supports the AWS Secrets Store CSI Driver provider | AWS](https://aws.amazon.com/jp/about-aws/whats-new/2025/11/amazon-eks-add-ons-aws-secrets-store-csi-driver-provider/)
- [Amazon EKS 用に AWS Secrets and Configuration Provider CSI を Pod Identity と使用する | AWS Systems Manager](https://docs.aws.amazon.com/ja_jp/systems-manager/latest/userguide/ascp-pod-identity-integration.html)
- [How to use the Secrets Store CSI Driver provider Amazon EKS add-on with Secrets Manager | AWS Security Blog](https://aws.amazon.com/jp/blogs/security/how-to-use-the-secrets-store-csi-driver-provider-amazon-eks-add-on-with-secrets-manager/)
- [Amazon EKS アドオンの高度な設定 | Amazon Web Services ブログ](https://aws.amazon.com/jp/blogs/news/amazon-eks-add-ons-advanced-configuration/)
- [aws/secrets-store-csi-driver-provider-aws | GitHub](https://github.com/aws/secrets-store-csi-driver-provider-aws)
- [aws-ebs-csi-driver/docs/install.md at master · kubernetes-sigs/aws-ebs-csi-driver | GitHub](https://github.com/kubernetes-sigs/aws-ebs-csi-driver/blob/master/docs/install.md)
- [Documentation on how to use a secret as an env var · Issue #286 · aws/secrets-store-csi-driver-provider-aws | GitHub](https://github.com/aws/secrets-store-csi-driver-provider-aws/issues/286)
- [Sync AWS Secrets manager with Kubernetes secrets on local not working when using minikube and localstack · aws/secrets-store-csi-driver-provider-aws · Discussion #230 | GitHub](https://github.com/aws/secrets-store-csi-driver-provider-aws/discussions/230)

[^1]: もともとkubernetes-extenal-secrets自体、[itscontained/secret-manager](https://github.com/itscontained/secret-manager)と[ContainerSolutions/externalsecret-operator](https://github.com/ContainerSolutions/externalsecret-operator)を統合するプロジェクトという[由来](https://github.com/external-secrets/kubernetes-external-secrets/issues/554#issuecomment-728984416)があります
[^2]: いわゆるinline volume
[^3]: コミュニティ提供のEKS Addonは、新クラスターバージョンが提供されてからしばらくたたないと対応しない場合が多いためクラスターバージョンの更新タイミングに影響を与えてしまう
[^4]: IRSAを利用する場合、`usePodIdentity: false`に設定します。
