---
Title: SBOMとSLSA状況
Category:
- C#
Date: 2026-01-16T23:00:00+09:00
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/17179246901345017359
PreviewURL: https://tech.guitarrapc.com/draft/entry/w-jopaAtUGS9qNFWUDNTh-Ss1Q4
CustomPath: 2026/01/16/230000
Draft: true
---

ソフトウェアのサプライチェインを担保する方法に、SBOMとSLSAがあります。 SBOM（Software Bill of Materials）は、そのソフトウェアの構成要素をリスト化したもの、SLSA（Supply chain Levels for Software Artifacts）は、ソフトウェア成果物の工程がどの程度信頼できるかを段階的に定義したフレームワークです。

今回は、2026年1月時点におけるSBOMとSLSAの状況について調べたことのメモです。この調査を元に、次回はC#ライブラリにおけるSBOMとSLSAについてみていきます。

[:contents]

## モチベーション

ここ数年OSSソフトウェアを利用した攻撃の1つとしてサプライチェイン攻撃を見かける頻度が上がっています。攻撃の最終目標は仮想通貨プラットフォームへの侵入だったりするようですが、OSSソフトウェアは他のOSSソフトウェアに依存していることが多いという性質から、攻撃者はその依存関係を悪用して攻撃を仕掛けることができます。

OSSライブラリ作者として自分が開発しているOSSライブラリがサプライチェイン攻撃に巻き込まれた際、その影響を早く確認し、また利用者に正当なライブラリであることを証明するのに役立つのがSBOMとSLSAです。これらを組み合わせることで、そもそもライブラリに影響しているのか確認しやすくし、またライブラリ利用者が正当なライブラリか検証しやすくなります。

今回の調査は、今後OSSライブラリ回りでSBOMやSLSAが要請されるようになる可能性もあるため、それに備えて現状の.NETにおけるSBOMとSLSAの状況を調べておくのを動機としています。

## サプライチェインとSBOMとSLSA

ソフトウェアのサプライチェインは2つの視点があります。SBOMとSLSAはそれぞれ別領域で、サプライチェインという視点では両者が揃うことで、ソフトウェアの信頼性を高めることができます。

1. そのソフトウェアは何でできているのか。構成しているソフトウェアは何なのか部品を明確にする -> SBOM
2. そのソフトウェアはどのように作られ、改ざんされていないかを保証する -> SLSA

つまりSBOMで何が入っているかをリストアップし、ハッシュで改ざんされてないか、SLSAのアテステーションで「そのハッシュが正規のビルド工程から生成されたという主張」を署名付きで提供するイメージです。

SBOMの例としてSPDX2.2フォーマットの一例を見てみましょう。filesに配布時含まれるファイル群、packagesにソフトウェアを構成するパッケージ群が記載されます。NOASSERTIONはSBOM発行時に指定しないなどの理由で情報がない場合に使われます。なるほど、確かにこれを見れば、そのソフトウェアが何でできているのか把握できます。

```json
{
  "file": [
    {
      "fileName": "./lib/libfoo.so",
      "SPDXID": "SPDXRef-File--lib-Example.libfoo-AAAAAAA",
      "checksums": [
        {
          "algorithm": "SHA256",
          "checksumValue": "ハッシュ値"
        },
        {
          "algorithm": "SHA1",
          "checksumValue": "ハッシュ値"
        }
      ],
      "licenseConcluded": "NOASSERTION",
      "licenseInfoInFiles": [
        "NOASSERTION"
      ],
      "copyrightText": "NOASSERTION"
    }
  ],
  "packages": [
    {
      "name": "Example.Package",
      "SPDXID": "SPDXRef-Package-Example.Package",
      "downloadLocation": "NOASSERTION",
      "filesAnalyzed": false,
      "licenseConcluded": "NOASSERTION",
      "licenseDeclared": "NOASSERTION",
      "copyrightText": "NOASSERTION",
      "versionInfo": "1.0.0",
      "externalRefs": [
        {
          "referenceCategory": "PACKAGE-MANAGER",
          "referenceType": "purl",
          "referenceLocator": "pkg:foo/Example.Package@1.0.0"
        }
      ],
      "supplier": "NOASSERTION"
    },
  ],
  "externalDocumentRefs": [],
  "relationships": [],
  "spdxVersion": "SPDX-2.2",
  "dataLicense": "CC0-1.0",
  "SPDXID": "SPDXRef-DOCUMENT",
  "name": "example-project-1.0.0",
  "documentNamespace": "http://spdx.org/spdxdocs/example-project-1.0.0-12345678",
  "creationInfo": {
    "created": "2026-01-16T12:00:00Z",
    "creators": [
      "Organization: ExampleOrg",
      "Tool: ExampleSBOMGenerator-1.0"
    ]
  },
  "documentDescribes": []
}
```

SLSAの例としてGitHub Actionsのアテステーションレポートを見てみましょう。ジョブでアテステーションレポートをid-token署名付きで生成、アテステーション一覧からたどることができます。ここには、いつ(日付)、だれが(実行者)、どこで(GitHubホステッド環境)、どのように(どの時点のどのワークフロー)そのソフトウェアを生成したかが記載されます。たしかにこれがあれば、そのソフトウェアがGitHub Actionsで生成されたことがわかります。

![SLSAの例](image.png)

SBOMで構成要素を把握し、SLSAでその生成プロセスを保証することで、ソフトウェアの信頼性を高めることができるという考え方とわかります。

### OSSライブラリ開発者にとってのメリット

OSSライブラリの開発者としては、自身のOSSライブラリの構成を把握し、配布物が外部から検証可能な形で提供できるとに一定のメリットがあります。

1. SBOMがあれば、サプライチェイン攻撃に巻き込まれたとき、いつの時点のライブラリが影響を受けたのか特定しやすくなる
2. SLSAがあれば、自身のライブラリが正当に生成されたものであることを示せる

サプライチェイン攻撃が発生したときにSBOMを確認することで、いつの時点のライブラリが影響を受けたのか特定しやすくなります。また、SBOM発行時の設定次第では、構成するライブラリにMPLやGPLライセンスなど自身が意図しないライセンスのライブラリが含まれているか確認できます。

SLSAはソフトウェアのサプライチェインのセキュリティレベルを評価するフレームワークで、レベル1(低)からレベル4(高)まであります。SLSAレベルが高いほどソフトウェアが改ざんされていないことを外部から検証しやすくなります。従来からSHA256などハッシュ値による検証はありましたが、そのハッシュ値が正当に生成されたものであるかまでは検証できません。それに対してSLSAは、例えばGitHub Actionsでビルドしてリリースしている場合に、ソフトウェアが生成されたから配布されるまでのプロセスと証明できる情報をセットにすることで、ただのハッシュ値検証よりも強力にパッケージの正当性を保証します。

もう少し詳しくSBOMとSLSAについて見ていきましょう。

## SBOM

SBOMは、そのソフトウェア(あるいはコンテナイメージ)に含まれる依存関係を、機械可読な形で列挙するものです。SBOMのフォーマットとしてSPDXとCycloneDXがよく使われますが、いずれにしてもSBOMには次の情報が記載されます。

- 使われているライブラリとそのバージョン
- 直接依存・間接依存の区別
- ライセンス情報
- ハッシュ

SBOMには、Source SBOMとBuild SBOMの2種類があります。Source SBOMは、ソースコードの依存関係から生成されるSBOMで、例えばロックファイル(packages.lock.json)から生成されます。一方、Build SBOMは、ビルド成果物から生成されるSBOMで、実際に含まれているライブラリを正確に反映します。

ただし、SBOMはSBOMファイルが正しいかは保証せず、改ざんされた場合もSBOM自体では判別できず、誰が作成したかの保証もできません。それって困りますよね？ ということで、成果物がどうやって生成されたかを保証するSLSAが補完的に欲しくなります。

### SBOMの生成ツール

OSSなら、[microsoft/sbom-tool](https://github.com/microsoft/sbom-tool)と[anchore/syft](https://github.com/anchore/syft)がよく利用されています。両方ともCLIツールを提供していますが、sbom-toolは.NET向けのMSBuildタスクがありNuGetパッケージ作成時に自動的に含めることができます。

また、GitHubもリポジトリ > Insights > Dependency graph > Generate SBOMからSBOMを生成できます。Export SBOMしたことはなくても、Dependency graphページをみたことがある人は多いんじゃないでしょうか。

![SBOMをエキスポート](image-1.png)

### SBOMのフォーマット

SBOMのフォーマットとして[SPDX](https://spdx.dev/)と[CycloneDX](https://cyclonedx.org/)がよく使われます。SPDXはLinux Foundationが策定したフォーマットで、オープンソースソフトウェアのライセンス情報を管理するために設計されました。一方、CycloneDXはOWASPが策定したフォーマットで、セキュリティに重点を置いています。どちらも広く使われていますが、SPDXはライセンス情報に強みがあり、CycloneDXはセキュリティ情報に強みがあります。

CycloneDXは、内部に脆弱性情報やアテステーション情報を持ちSLSA周辺ツールと連携しやすいため、開発中のソフトウェアのSBOM生成に向いています。一方、SPDXはライセンス情報に強みがあり、配布物に同梱するSBOMとして向いています。どっちかのフォーマットに統一するという感じではないようです。

OSSライブラリ開発者としては、配布物にSBOMを同梱する場合はSPDX、CI/CDパイプラインで生成する場合はCycloneDXを選ぶとよいでしょう。なお、SPDXにはバージョン[2.2](https://spdx.github.io/spdx-spec/v2.2.2/)/[2.3](https://spdx.github.io/spdx-spec/v2.3/)と[3.0](https://spdx.github.io/spdx-spec/v3.0.1/)がありますが、現時点では2.2/2.3対応ツールが主流なため3.0に手を出すのはまだ早い印象です。3.0はフォーマットから刷新されて、2.2/2.3とは互換性がないのも注意点です。

## SLSA

SLSAは、その成果物が信頼できる工程で作られたことを段階的に保障することを目的としたフレームワークです。SLSA v1.0には4つのレベルがあり、レベルが上がるほど信頼性が高くなります。

- Level 1: ビルド履歴がある
- Level 2: ビルドが自動化されている
- Level 3: ビルドが改ざん不能
- Level 4: 再現可能・検証可能

GitHub Actionsを使うことで、ビルド履歴や自動化が実現できるのでSLSAレベル1と2は比較的簡単に達成できます。先のアテステーションレポートはレベル2の提供です。レベル3にはワークフローが改ざんできないような工夫を要します。GitHubでのSLSA対応は[ドキュメント](https://docs.github.com/en/actions/concepts/security/artifact-attestations)が用意されているので参考になります。

ただ、アテステーションレポートがあるかといってソフトウェアが安全である保障はないことには注意が必要です。ソフトウェアのソースコードとビルド手順へのリンクは提供されますが、ソフトウェア自体のリスク判断は行いません。例えば、悪意のあるコードがソースコードに含まれている場合、そのソースコードをビルドした成果物はSLSAレベル4であっても安全とは言えません。

### SLSAの生成

### SLSAレベル3は現実的なのか

SLSAレベル3の改ざん不能とは、誰も変更できないことを意味するのではなく、変更された場合にその事実を後から検証できる、という意味である点には注意が必要です。言い換えると、改ざん不能は、「そのビルド成果物が事前に定義されたビルド手順から人の手による介入なく生成されたものであることを後から検証できる」ことを意味します。

SLSAレベル3はホスト環境を求めていますが、これはビルド環境の完全性をGitHubなどクラウド事業者の責任範囲において、代わりにユーザーが直接触れないことを信頼の根拠にしているととらえられます。GitHub ActionsのホステッドランナーはMicrosoftが管理しており、ユーザーはその環境に直接アクセスできません。つまり、ビルド環境の完全性をMicrosoftに依存することで、ユーザーはビルド環境が改ざんされていないことを信頼できます。

**誤解していたこと**

改ざん不能はビルドステップ自体を変更できないという意味ではないことは注意が必要です。私はこれを当初誤解していました。GitHub ActionsでSLSA3を達成するための[ドキュメント](https://docs.github.com/en/actions/how-tos/secure-your-work/use-artifact-attestations/increase-security-rating)が提供されています。これはビルドにReusable Workflowを使うことを求めていますが、ビルドステップを別リポジトリで管理するのが直接的にビルド自体が改ざん不能になるかというと、個人的には疑問があります。そのリポジトリがプライベートリポジトリである場合、「ビルドステップは外部から改ざん不能である」と言えそうですが、パブリックリポジトリである場合、誰でもプルリクエストを送れるため「ビルドステップが改ざん不能であるとは言い切れない」です。改ざん不能はあくまでも外部からのPRを受け付けない、内部の変更に対しても注意を払うしかないという「かいざん不能」という字面通りの言葉ほど強い統制はとりにくい[^1]でしょう。

**改ざん不能が意味すること**

実際には、改ざん不能はその時点で有効だったリリースワークフローから自動的に作られたことを守ることを指しています。つまり、PRなどリリース以外の経由で成果物を差し替えたり、手動アップロードで差し替える、アテステーションレポートを捏造することを防ぐのがレベル3です。一方、メンテナの悪意やレビューの質、PRでリリースワークフローを変更できるかなどは対象にしていません。

とはいえ、GitHubがSLSAレベル3にReusable Workflowを用いることを求めるのはコンテキストがズレている感じはぬぐえないのですが...。

## SBOMとSLSAの活用例

### SBOMをライセンスリスク管理に使う

SBOMでライセンス情報も出力することで、ライセンスリスク管理が可能になります。例えば、MITで配布したいライブラリに、GPLライセンスや商用ライセンスが混入することは避けたいでしょう。しかし、ライブラリの依存関係が複雑になると、どのライブラリがどのライセンスなのか把握するのは困難です。SBOMを使うことで、ライセンス情報を自動的に収集し、ライセンスリスクを管理できます。

### SLSAをアーティファクトのハッシュ値検証に使う

SLSAアテステーションが発行されていると、単にハッシュ値を配布するだけでなく「ハッシュが何のか + そのハッシュがどの工程で生成されたか」まで含めて検証できるようになります。よくリリースアーティファクトに`libfoo.so`と`libfoo.so.sha256`のように提供されているハッシュ値は、ダウンロード途中で改ざんされた際に改ざんを検出できるものの、そのハッシュ値自体が改ざんされていた場合には検出できません。つまり、攻撃者が`libfoo.so`と`libfoo.so.sha256`の両方を改ざんした場合、利用者がそれを検出できる仕組みではありません。

SLSAアテステーションレポートには、対象アーティファクトのハッシュ値が含まれ、利用者はそのビルドステップで生成されたものであることを検証できます。GitHub Actionsでやるなら1つステップを追加するだけで済むので、楽になったなぁという印象があります。

```yaml
- name: Generate artifact attestation
  uses: actions/attest-build-provenance@977bb373ede98d70efdf65b84cb5f73e068dcc2a # v3.0.0
  with:
    subject-path: "./publish/libfoo.so"
```

## まとめ

個人的に調べたSBOMとSLSAの状況についてのメモ書きでした。

OSSライブラリ開発者としては、SBOMを配布物に同梱することは悪くなさそうです。ただGitHubのInsightsから見てもらったり、Dependabotに任せることができている現状からすると、SBOMを積極的に活用する場面はまだ少ない印象です。標準ビルドで自動的に生成されるなら、配布パッケージに入れても損はないかなという温度感。

SLSAに関しては、GitHub Actionsを使っている場合はアテステーションレポートを生成するのは簡単なので、OSSライブラリの信頼性を高めるために導入自体は悪くなさそうです。ただ、SLSAレベル3以上を目指すにあたりReusable Workflowが必要かは納得がいかないですね。OSSライブラリ開発者としては、SLSAレベル2 + アテステーションレポートを添えるのが現実的な線に感じます。

## 参考

GitHub

- [microsoft/sbom-tool | GitHub](https://github.com/microsoft/sbom-tool)
- [anchore/syft | GitHub](https://github.com/anchore/syft)

規格

- [CycloneDX Bill of Materials Standard | CycloneDX](https://cyclonedx.org/)
- [SPDX – Linux Foundation Projects Site](https://spdx.dev/)
- [SPDX - Specification v2.2.2](https://spdx.github.io/spdx-spec/v2.2.2/)
- [SPDX - Specification v2.3.0](https://spdx.github.io/spdx-spec/v2.3/)
- [SPDX - Specification v3.0.1](https://spdx.github.io/spdx-spec/v3.0.1/)

ドキュメント

- [Artifact attestations - GitHub Docs](https://docs.github.com/en/actions/concepts/security/artifact-attestations)
- [Using artifact attestations to establish provenance for builds - GitHub Docs](https://docs.github.com/en/actions/how-tos/secure-your-work/use-artifact-attestations/use-artifact-attestations)
- [Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3 - GitHub Docs](https://docs.github.com/en/actions/how-tos/secure-your-work/use-artifact-attestations/increase-security-rating)

ブログ

- [標準SBOMフォーマットについての解説 #Security - Qiita](https://qiita.com/AyumiWatanabe/items/52bb71d5cecad1614851)
- [SBOMを噛み砕く | Zenn](https://zenn.dev/sta/books/sbom-kamikudaku)



[^1]: できないとは言わないのですが、それを担保、その時点では改ざんされていないことは検証できても、改ざんされないと保証できるものではないという温度感。
