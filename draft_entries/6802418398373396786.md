---
Title: GitHub ActionsのCVE-2025-30066を受けたワークフローの変化
Category:
- CI/CD
Date: 2025-04-05T23:59:00+09:00
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/6802418398373396786
PreviewURL: https://tech.guitarrapc.com/draft/entry/Kc53P5y5ZmeEXucwetdqoul38bw
CustomPath: 2025/04/05/235900
Draft: true
---

2025年3月28日にあったtj-actionやreviewdogのセキュリティインシデント[CVE-2025-30066](https://nvd.nist.gov/vuln/detail/CVE-2025-30066)を受けて、GitHub Actionsワークフローの書き方が変えてしばらく経ちました。

今回はそのメモです。

[:contents]

# CVE-2025-30066の概要

[セキュリティインシデント](https://unit42.paloaltonetworks.com/github-actions-supply-chain-attack/)に詳しいですが、簡単に説明すると[spotbugs/sonar-findbugs](https://github.com/spotbugs/sonar-findbugs)を起点に[reviewdog/action-setup](https://github.com/reviewdog/action-setup)を経由して[tj-action/changed-files](https://github.com/tj-actions/changed-files)のリリースのほとんどが改ざんされました。改ざんコミットは、base64エンコードされたPythonのエクスプロイトコードを取得/実行するもので、GitHub Actionsのランナーで実行されると、GitHub Actionsのシークレットを取得してログ出力します。攻撃者の狙いは[coinbase/agentkit](https://github.com/coinbase/agentkit)だったようですが、tj-action/changed-filesの利用者が多く、影響範囲が広がりました。

分かりやすいユーザーインパクトは、tj-action/changed-filesのタグ指定で利用しているGitHub ActionsワークフローにてGitHub Actionsのランナーで利用しているシークレットがActionログに出力されます。プライベートリポジトリにおいてはCIログは外部から確認できないため限定的ですが、公開リポジトリにおいてはビルドログを第三者が確認できるためGitHub Actionsのシークレットが漏洩します。

なお、CVE発生時にGitHubは次の対応をしています。

* tj-action/changed-filesのリポジトリ/アクションを削除してワークフロー使用できないように変更
* アクションのすべてのリリースがクリーンアップ、悪意あるコードが含まれなくなってからリポジトリを復旧
* 悪意のあるユーザーjurkaofavak/randolzfowの削除
* Gistに公開されていたエクスプロイトで利用されたPythonコードの削除[^1]
* 各ユーザーのGitHub PATを期限切れに設定 (各ユーザーはPATを発行しなおしたはずです)

# CVE-2025-30066の影響を軽減するにはどうすればよいのか

CVE-2025-30066のようなGitHub Actionsのインシデントは今後も起こる可能性が高いです。GitHub Actionsはオープンソースであり誰でもアクションを作成できますし、メンテナのPATが漏洩して意図せず変更される可能性もあるでしょう。
利用者としては改めて認識したポイントは次の通りです。

1. アクションのタグ/リリースは書き換えられる可能性がある
3. 利用者のPersonal Access Token (PAT)やGITHUB Appはアクションで漏れる可能性がある
4. ワークフローやジョブに設定した環境変数はアクションによってCIログに書き出せる
5. ワークフローやジョブの権限が高いほどインパクトが大きい
6. パブリックリポジトリの`pull_request_target`イベントの利用はリスクが高い
7. コミットは別ユーザーで偽れる

利用者として軽減策を考えてみましたが、多いですね。優先度をつけないと大変ですが、静的解析ツールで自動検知できるものから対処していくと良さそうです。

* アクションはタグ/リリースではなくコミットSHAを指定する (pinactで対応可能)
* ワークフローに指定するPATやGITHUB Appは権限を最小限にする
* シークレットを環境変数に設定する場合、ステップの環境変数に設定する (ghalintで検出可能)
* ジョブごとに最小権限を設定する (ghalintで検出可能)
* リポジトリの自動アクショントークンのデフォルト権限を`write`から`read`に設定しなおす[^2]
* パブリックリポジトリで`pull_request_target`イベントは極力避ける (ghalint/zizmorで検出可能)
* Rulesetでコミット署名の必須化を検討する
* Rulesetでタグの更新・削除を禁止
* Rulesetでタグの作成可能なユーザーをorganization adminやrepository adminに限定する

# 事前準備としての静的解析ツール

真っ先に取り組むべきは静的解析ツールによる自動化です。リポジトリを複数管理していると手動でワークフローを調整するのは無理です。時間は有限なので、できるだけ自動化して見落としを防ぎつつ精度を高めましょう。

以下のツールを利用して、ワークフローの静的解析ができます。

| ツール名 | 説明 |
| --- | --- |
| [actionlint](https://github.com/rhysd/actionlint) | ワークフローの構文チェックとShellcheckなど |
| [ghalint](https://github.com/suzuki-shunsuke/ghalint) | ワークフローの簡易的なセキュリティチェック |
| [zizmor](https://github.com/woodruffw/zizmor) | ワークフローのより厳しいセキュリティチェック |

以下のツールを利用して、セキュリティプラクティスをワークフローに自動適用できます。

| ツール名 | 説明 |
| --- | --- |
| [pinact](https://github.com/suzuki-shunsuke/pinact) | タグやブランチ指定されたアクションをSHAに変換する |
| [disable-checkout-persist-credentials](https://github.com/suzuki-shunsuke/disable-checkout-persist-credentials) | checkoutアクションの`persist-credentials`を無効化する |

私のおすすめは、次の流れです。

1. pinactでSHAに変換する
2. Dependabotでアクション更新を自動化
3. disable-checkout-persist-credentialsで`checkout`アクションの`persist-credentials`を無効化する
4. actionlintを実行してワークフロー構文を標準化する
5. ghalintでセキュリティチェックを実行して、出てきたエラー/警告を修正する
6. (Optional) zizmorでセキュリティチェックを実行して、出てきたエラー/警告を修正する

## pinact

pinactはGitHub ActionsのタグやブランチをSHAに一括変換するツールです。SHAに変換することで、今回のインシデントのようにタグに悪意のあるコードが仕込まれた場合でも影響を受けません。[^3]
後述する`ghalint`で指摘されるのですが、pinactコマンドを叩くだけで単に修正できます。

[f:id:guitarrapc_tech:20250430192822p:plain:alt=ghalintのエラー例]

```sh
$ pinact run
```

**嬉しいポイント**

コマンドを実行するだけでSHAに変換されるので、手作業より圧倒的に簡単、確実です。SHAにしたいなら`pinact`で99％解決します。コンフィグファイルもありますが、おおむね不要でしょう。

```yaml
# ❌: tag指定
- uses: actions/checkout@v4

# ⭕: SHA指定
- uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
```

ドキュメントもアップデート対象にできますが、これはうまくいかないケースもあるようなのでうまくいったら便利程度でいいでしょう。

**つらいポイント**

Organization内部で常にブランチを見たいケースでSHAに変換されるのは邪魔です。先ほどの1％に該当するので都度対処でいいです。コンフィグの`ignore_actions`に指定するとSHAに変換されないようにできます。

```yaml
# 意図的にブランチを指定したいケースでSHAに変換されると面倒
- uses: foo-organization/bar-action@main
```

## Dependabot

リポジトリにDependabot[^4]の設定ファイル`.github/dependabot.yaml`を用意しておくとDependabotによるGitHub Actionsのバージョン更新が自動化できます。幸いにしてSHAで指定した場合でもDependabotはSHAを更新してくれます。

```yaml
# 元がSHA指定でも
- uses: actions/download-artifact@95815c38cf2ff2164869cbab79da8d1f422bc89e # v4.2.1

# Dependabotは更新してくれる
- uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
```

**更新頻度を調整する**

頻繁すぎる更新は好ましくないと考えているので、週一更新かつパッチバージョンは更新しないようにしています。普段使っている設定は次の通りです。

```yaml
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly" # Check for updates to GitHub Actions every week
    ignore:
      # I just want update action when major/minor version is updated. patch updates are too noisy.
      - dependency-name: '*'
        update-types:
          - version-update:semver-patch

```

## disable-checkout-persist-credentials

GitHub Actionsでチェックアウトするときは`actions/checkout`を使うのが定番です。ただデフォルトで`persist-credentials: true`になっており、悪意あるアクションがリポジトリにコミット障壁が`permission`だけです。明示的に`persist-credentials: false`を設定することで、チェックアウト後のGit認証情報を無効してGit認証情報にアクセスできるステップを限定できます。

後述する`ghalint`や`zizmor`で指摘されるのですが、`disable-checkout-persist-credentials`コマンドを叩くだけで簡単に修正できます。

[f:id:guitarrapc_tech:20250430192830p:plain:alt=ghalintのエラー例]

[f:id:guitarrapc_tech:20250430192838p:plain:alt=zizmorのエラー例]u

```
$ disable-checkout-persist-credentials
```

**嬉しいポイント**

コマンドを実行するだけで`persist-credentials: false`が設定されるので、手作業より圧倒的に簡単、確実です。

```yaml
# ❌: persist-credentialsがtrueだとghalintでエラーが出る
- uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
  with:
    persist-credentials: true

# ❌: persist-credentialsが無指定(true相当)だとghalintとzizmorでエラーが出る
- uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

# ⭕: persist-credentialsがfalseを指定する
- uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
  with:
    persist-credentials: false
```


**後続ステップで`git push`するには**

`persist-credentials: false`にすると、後続のステップでプッシュできなくなります。

```sh
fatal: could not read Username for 'https://github.com': No such device or address
Failed to push, try 'git pull --rebase' to resolve ...
```

GitHub Actionsでプッシュするには、`git remote set-url`で認証付きリモートURLを設定してあげる必要があります。コミット前にリモートリポジトリ情報をセットしてあげれば、`persist-credentials: true`の頃と同様にpushできるようになります。

```yaml
# ❌: git pushができない
- name: git push
  run: git push

# ⭕: コミット前にリモートリポジトリ情報をセットする
- name: update current git to latest & Push changes
  shell: bash
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  run: |
    git remote set-url origin "https://github-actions:${GITHUB_TOKEN}@githb.com/${{ github.repository }}"
    git config user.name  "github-actions[bot]"
    git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
- name: git push
  run: git push
```

## actionlint

ここまでのツールはGitHub Actionsのワークフローを修正するためのツールです。ここからは静的解析ツールです。

actionlintはGitHub Actionsのワークフローの構文チェックを行うツールです。構文チェックだけでなく、Shellcheckやpyflakeなども実行してくれます。YAMLの書き方が人それぞれなのはしょうがないですが、actionlintはYAML Lintを実行してくれるので、YAMLの書き方を統一するのに役立ちます。

```sh
$ actionlint
```

actionlintを使うと、次のような状況を改善できます。

- GitHub Actionsのワークフローの妥当性検出
- GitHub Actionsの`${{ }}`構文の妥当性を検出
- `runs-on`に指定された不明なランナーを検出
- `github`コンテキストでリスクが高いパラメーターをrunsに直接埋め込んでいると検出

[f:id:guitarrapc_tech:20250430192848p:plain:alt=actionlintの検出例]

```yaml
# ❌: runs-onがないのでエラー
jobs:
  dump-context:
    timeout-minutes: 5
    steps:
      - run: echo foo

# ⭕: runs-onを指定する
jobs:
  dump-context:
    timeout-minutes: 5
    runs-on: ubuntu-24.04
    steps:
      - run: echo foo
```

[f:id:guitarrapc_tech:20250430192857p:plain:alt=actionlintでruns-onがないのを検出]

**嬉しいポイント**

actionlintが何かしら検出すると終了コードが1になるので、CI/CDで使いやすいです。後述しますが、私はCI/CDでactionlintを用いています。

## ghalint




## zizmor

zizmorはghalintよりもチェックが厳し目です。このため嬉しい面とちょっとつらい面があります。
私の場合、4つのポイントが引っかかりました。

**嬉しいポイント**

例えば、以下はghalintではエラーにならないのでzizmorで気づけるのは嬉しいです。

再利用可能なワークフローで`secrets: inherit`をエラーにするのは割といい指摘に感じます。ついやっちゃいがちですが、パブリックなリポジトリではsecretsをちゃんと明示するほうがいいでしょう。

```yaml
# ❌: secretsをinheritにするとmedium levelのエラーが出る
jobs:
  call-workflow-passing-data:
    uses: ./.github/workflows/_reusable-workflow-called.yaml
    with:
      username: ${{ inputs.username }}
      is-valid: ${{ inputs.is-valid }}
    secrets: inherit

# ⭕: secretsを明示する
jobs:
  call-workflow-passing-data:
    uses: ./.github/workflows/_reusable-workflow-called.yaml
    with:
      username: ${{ inputs.username }}
      is-valid: ${{ inputs.is-valid }}
    secrets:
      APPLES: ${{ secrets.APPLES }}
```

actions/checkoutで`persist-credentials: false`が指定されていないとエラーにするのもいい感じです。

```yaml
# ❌: persist-credentialsがtrueだとmedium levelのエラーが出る
- uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

# ⭕: persist-credentialsがfalseだとエラーにならない
- uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
  with:
    persist-credentials: false
```

**つらいポイント**

修正してみて、これをあげられるのは特につらかったポイントを紹介します。

inputsは不正な文字列を差し込まれる可能性があるので環境変数を使えという指摘です。booleanなどinputs次第で問題ない可能性があるにも関わらずinputsに対して一律厳しいのはめんどくさく感じました。

```yaml
# ❌: runでinputsを直接使おうとするとhigh levelのエラーが出る
- name: Output foo input
  shell: bash
  run: echo "foo is ${{ inputs.foo != '' && inputs.foo || env.FOO }}"

# ⭕: 環境変数にいれてから環境変数をrunで指定する。
- name: Output foo input
      shell: bash
      run: echo "foo is ${VALUE}"
      env:
        VALUE: ${{ inputs.foo != '' && inputs.foo || env.FOO }}
```

githubコンテキストも不正な文字列を差し込まれる可能性があるので環境変数を使えという指摘です。ブランチ名やIssueタイトルなど、コミッターが自由にいじれるものはインジェクション余地があるのでまずいのは同意ですが、`event_name`などGitHubコンテキストすべてに一律厳しいのはめんどくさく感じました。

```yaml
# ❌: event_nameを直接使おうとするとhigh levelのエラーが出る
- name: file names
  id: file
  run: echo "name=${{ github.event_name }}${{ github.event.action != '' && format('_{0}', github.event.action) || ''}}${{ github.event_name == 'push' && format('_{0}', github.ref_type) || ''}}" | tee -a "$GITHUB_OUTPUT"

# ⭕: 環境変数にいれてから環境変数をrunで指定する。
- name: file names
  id: file
  env:
    EVENT_NAME: ${{ github.event_name }}
    EVENT_ACTION: ${{ github.event.action }}
    REF_TYPE: ${{ github.ref_type }}
  run: |
    ACTION_PART=""
    if [ -n "$EVENT_ACTION" ]; then
      ACTION_PART="_${EVENT_ACTION}"
    fi

    REF_PART=""
    if [ "$EVENT_NAME" = "push" ]; then
      REF_PART="_${REF_TYPE}"
    fi

    FILENAME="${EVENT_NAME}${ACTION_PART}${REF_PART}"
    echo "name=$FILENAME" | tee -a "$GITHUB_OUTPUT"
```

# GitHub Actionsで静的解析ツールを自動化する

静的解析ツールをGitHub Actionsで自動実行すると、意図しないミスを素早く検出/修正できます。aquaでツールバージョンを設定しておくと、ローカルとCI/CDで同じバージョンを簡単に利用できて再現性が高くオススメです。

例えば次のようなaqua.yamlをリポジトリルートに設定しておきます。

```yaml
---
# aqua - Declarative CLI Version Manager
# https://aquaproj.github.io/
# checksum:
#   enabled: true
#   require_checksum: true
#   supported_envs:
#   - all
registries:
- type: standard
  ref: v4.332.0 # renovate: depName=aquaproj/aqua-registry
packages:
- name: rhysd/actionlint@v1.7.7
- name: suzuki-shunsuke/ghalint@v1.2.3

```

あとはGitHub Actionsを用意するだけです。

```yaml
name: actionlint
on:
  workflow_dispatch:
  pull_request:
    branches: ["main"]
    paths:
      - ".github/workflows/**"
  schedule:
    - cron: "0 0 * * *"

jobs:
  lint:
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false
      - uses: aquaproj/aqua-installer@e2d0136abcf70b7a2f6f505720640750557c4b33 # v3.1.1
        with:
          aqua_version: v2.43.1
      # github workflows/action's Static Checker
      - name: Run actionlint
        run: actionlint -color -oneline
      # checkout's persist-credentials: false checker
      - name: Run ghalint
        run: ghalint run
      # A static analysis tool for GitHub Actions
      - name: Run zizmor
        run: docker run -t -v .:/github ghcr.io/woodruffw/zizmor:1.5.2 /github --min-severity medium

```


# 参考

* [NVD - CVE-2025-30066](https://nvd.nist.gov/vuln/detail/CVE-2025-30066)
* [GitHub Actions Supply Chain Attack: A Targeted Attack on Coinbase Expanded to the Widespread tj-actions/changed-files Incident: Threat Assessment (Updated 4/2)](https://unit42.paloaltonetworks.com/github-actions-supply-chain-attack/)
* [Semgrep | 🚨 Popular GitHub Action tj-actions/changed-files is compromised](https://semgrep.dev/blog/2025/popular-github-action-tj-actionschanged-files-is-compromised/)
* [Harden-Runner detection: tj-actions/changed-files action is compromised - StepSecurity](https://www.stepsecurity.io/blog/harden-runner-detection-tj-actions-changed-files-action-is-compromised)



* [tj-actions のインシデントレポートを読んだ](https://zenn.dev/shunsuke_suzuki/articles/tj-actions-incident-2025#fork-network-%E3%81%AE%E6%82%AA%E7%94%A8)
* [GitHub のセキュリティ改善](https://zenn.dev/shunsuke_suzuki/articles/github-security-2025)
* [GitHub Actions を静的検査するツールの紹介 (actionlint/ghalint/zizmor)](https://zenn.dev/kou_pg_0131/articles/gha-static-checker)
* https://zenn.dev/shunsuke_suzuki/articles/github-action-checkout-persist-credentials


[^1]: https://gist.githubusercontent.com/nikitastupin/30e525b776c409e03c2d6f328f254965/raw/memdump.py
[^2]: 新しいリポジトリを作るとデフォルト`read`ですが、以前からのリポジトリはデフォルト`write`になっています
[^3]: コミットで同一SHAに衝突されるケースでは問題になる可能性がありますが、それを言い出すとGitという仕組み自体を考え直すことになるので考慮外とします
[^4]: もしRenovateを使っているならそれでもいいです。
