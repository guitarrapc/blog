---
Title: NuGetのロックファイルは使うべきなのか
Category:
- C#
Date: 2026-01-11T23:00:00+09:00
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/17179246901343941401
PreviewURL: https://tech.guitarrapc.com/draft/entry/w4e8xX7uO3JSNuAH5FqLdjqQLQY
CustomPath: 2026/01/11/230000
Draft: true
---

NuGetにはロックファイル(packages.lock.json)を用いてリストアする機能があります。
ただ、C#のプロジェクトでロックファイルを使っている例はあまり見かけません[^1]。

最近、sbomについて調べる中で、NuGetのロックファイルがあまり使われていない理由について考えていたのでメモです。

[:contents]

## ロックファイルとは

ロックファイルとは、プロジェクトが依存するパッケージのバージョンを固定化するためのファイルです。

プロジェクトが依存するパッケージには、直接依存するもの(トップレベル)と、間接的に依存するもの(トランジティブ)があります。
イメージしやすいようにnpmで例えると、[@modelcontextprotocol/sdk](https://www.npmjs.com/package/%40modelcontextprotocol/sdk)パッケージを入れるとします。
この場合、`@modelcontextprotocol/sdk`が直接依存するパッケージで、`@hono/node-server`や`ajv`などは間接的に依存するパッケージです。

![npmで@modelcontextprotocol/sdkの間接的に依存するパッケージが確認できる](image.png)

ロックファイルは、あるパッケージをインストールしたときのバージョンと、そのパッケージを導入したときに推移的にインストールされたパッケージのバージョンを記録します。これにより、同じプロジェクトを別の環境でセットアップしたときに、同じバージョンのパッケージがインストールされることを保証します。

## NuGetのロックファイル

デフォルトでは無効になっていますが、NuGetにもロックファイルを利用する機能があります。
NuGetでロックファイルを利用するには`RestorePackagesWithLockFile`プロパティを`true`に設定して、プロジェクトをリストアします。すると、`.csproj`があるパスに`packages.lock.json`というファイルが生成されます。

```xml
  <PropertyGroup>
    <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>
  </PropertyGroup>
```

試しにロックファイルを追加してみましょう。プロジェクト追加、初回のパッケージ追加、リストア、ロックファイル追加後のリストアを順に実行します。今回は[SkiaSharp.QrCode](https://www.nuget.org/packages/SkiaSharp.QrCode)パッケージを使用します。NuGetを見ると、SkiaSharpやSkiaSharp.NativeAssets.macOS/SkiaSharp.NativeAssets.Win32に依存していることがわかります。

![NuGetのパッケージ依存関係](image-1.png)

```shell
$ mkdir -p ConsoleApp3 && cd ConsoleApp3
$ dotnet new console -n ConsoleApp3
$ dotnet package add SkiaSharp.QrCode
$ dotnet restore
Restore complete (0.9s)

Build succeeded in 1.1s

$ ls -la
ls -la
total 16
drwxrwxr-x    3 guitarrapc   guitarrapc      0 Jan 14 16:58 .
drwxrwxr-x    8 guitarrapc   guitarrapc   4096 Jan 14 16:58 ..
-rw-rw-r--    1 guitarrapc   guitarrapc    356 Jan 14 16:59 ConsoleApp3.csproj
-rw-rw-r--    1 guitarrapc   guitarrapc    105 Jan 14 16:58 Program.cs
drwxrwxr-x    2 guitarrapc   guitarrapc   4096 Jan 14 17:00 obj

$ cat <<EOF > ConsoleApp3.csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>

    <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="SkiaSharp.QrCode" Version="0.12.0" />
  </ItemGroup>

</Project>
EOF

$ dotnet restore
Restore complete (0.6s)

Build succeeded in 1.1s

$ ls -la
ls -la
total 24
drwxrwxr-x    3 guitarrapc   guitarrapc   4096 Jan 14 17:03 .
drwxrwxr-x    8 guitarrapc   guitarrapc   4096 Jan 14 16:58 ..
-rw-rw-r--    1 guitarrapc   guitarrapc    427 Jan 14 17:03 ConsoleApp3.csproj
-rw-rw-r--    1 guitarrapc   guitarrapc    105 Jan 14 16:58 Program.cs
drwxrwxr-x    2 guitarrapc   guitarrapc   4096 Jan 14 17:03 obj
-rw-rw-r--    1 guitarrapc   guitarrapc   1314 Jan 14 17:03 packages.lock.json  # <- 追加!

$ cat packages.lock.json
{
  "version": 1,
  "dependencies": {
    "net10.0": {
      "SkiaSharp.QrCode": {
        "type": "Direct",
        "requested": "[0.12.0, )",
        "resolved": "0.12.0",
        "contentHash": "DTSyBl/rJXcGbSuIzkv20pkTTPUaZbFmouWrOtHG0a2Ide0IsbU9o1mUJb1HsiOgUEK6aAX2+MzP0n7GPssiSA==",
        "dependencies": {
          "SkiaSharp": "3.119.1",
          "SkiaSharp.NativeAssets.Win32": "3.119.1",
          "SkiaSharp.NativeAssets.macOS": "3.119.1"
        }
      },
      "SkiaSharp": {
        "type": "Transitive",
        "resolved": "3.119.1",
        "contentHash": "+Ru1BTSZQne3Vp+vbSb50Ke3Nlc3ZnItxx4+751J9WZ8YzLKAV/n+9DAo4zFTyeCI//ueT63c+VybmTTpYBEiw==",
        "dependencies": {
          "SkiaSharp.NativeAssets.Win32": "3.119.1",
          "SkiaSharp.NativeAssets.macOS": "3.119.1"
        }
      },
      "SkiaSharp.NativeAssets.macOS": {
        "type": "Transitive",
        "resolved": "3.119.1",
        "contentHash": "6hR3BdLhApjDxR1bFrJ7/lMydPfI01s3K+3WjIXFUlfC0MFCFCwRzv+JtzIkW9bDXs7XUVQS+6EVf0uzCasnGQ=="
      },
      "SkiaSharp.NativeAssets.Win32": {
        "type": "Transitive",
        "resolved": "3.119.1",
        "contentHash": "8C4GSXVJqSr0y3Tyyv5jz6MJSTVUyYkMjeKrzK+VyZPGLo89MNoUEclVuYahzOCDdtbfXrd2HtxXfDuvoSXrUw=="
      }
    }
  }
}
```

期待通り、ロックファイルが追加されました。中身を見ると、プロジェクトで直接参照させたパッケージ`SkiaSharp.QrCode`には`"type": "Direct"`が指定され、`SkiaSharp.QrCode`ライブラリが依存している`SkiaSharp`や`SkiaSharp.NativeAssets.Win32`などのパッケージには`"type": "Transitive"`が指定されています。

### ロックファイルを使ったリストア

ロックファイルを使用している場合、`dotnet restore`コマンドは`packages.lock.json`ファイルを参照して、NuGetの依存を再評価しつつ指定されたバージョンのパッケージをインストールします。この時パッケージが取得できなかったなど必要があればバージョンが更新されます。

`npm ci`のように、ロックファイルに記録されたバージョンを厳密に再現する場合、`dotnet restore --locked-mode`コマンドを使うか、`<RestoreLockedMode>true</RestoreLockedMode>`を設定します。npm同様、CIではこのオプションを有効にするのがいいでしょう。

ローカルでは通常の`dotnet restore`を実行し、CIではロックファイルに厳密に従うようにするなら次のように設定します。これにより、異なる環境であっても同じバージョンのパッケージが保証されます。

```xml
  <PropertyGroup>
    <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>
    <RestoreLockedMode Condition="'$(CI)' == 'true'">true</RestoreLockedMode>
  </PropertyGroup>
```

### ロックファイルとCentral Package Managementの組み合わせ

ロックファイルを使ってみると、[Central Package Management](https://learn.microsoft.com/ja-jp/nuget/consume-packages/central-package-management)(Directory.Packages.props)に対応していないことに気づきます。このため、`Directory.Packages.props`でバージョンを一元管理していても、ロックファイルは個々の.csprojパスに生成されます。

試してみましょう。ConsoleApp4とConsoleApp5の2つのプロジェクトを持つソリューションを作成し、`Directory.Packages.props`で`SkiaSharp.QrCode`のバージョンを一元管理します。ロックファイル`packages.lock.json`は`、Directory.Packages.props`のパスではなく各プロジェクトに生成されることを確認します。

```shell
$ cat <<EOF > Directory.Build.props
<Project>
  <PropertyGroup>
    <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>
    <RestoreLockedMode Condition="'$(CI)' == 'true'">true</RestoreLockedMode>
  </PropertyGroup>
</Project>
EOF

$ cat <<EOF > Directory.Packages.props
<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
    <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
  </PropertyGroup>
  <ItemGroup>
    <PackageVersion Include="SkiaSharp.QrCode" Version="0.12.0" />
  </ItemGroup>
</Project>
EOF

$ mkdir -p src/ConsoleApp4 && cd src/ConsoleApp4
$ dotnet new console -n ConsoleApp4
$ dotnet package add SkiaSharp.QrCode

$ ../../
$ mkdir -p src/ConsoleApp5 && cd src/ConsoleApp5
$ dotnet new console -n ConsoleApp5
$ dotnet package add SkiaSharp.QrCode

$ ../../
$ dotnet new sln -f slnx
$ dotnet sln add src/ConsoleApp4/ConsoleApp4.csproj
$ dotnet sln add src/ConsoleApp5/ConsoleApp5.csproj
$ dotnet restore
Restore complete (1.4s)

Build succeeded in 1.7s

$ ls -laR
.:
total 20
drwxrwxr-x    3 guitarrapc   guitarrapc   4096 Jan 14 17:41 .
drwxrwxr-x    8 guitarrapc   guitarrapc   4096 Jan 14 16:58 ..
-rw-rw-r--    1 guitarrapc   guitarrapc    210 Jan 14 17:38 Directory.Build.props
-rw-rw-r--    1 guitarrapc   guitarrapc    327 Jan 14 17:39 Directory.Packages.props
-rw-rw-r--    1 guitarrapc   guitarrapc    181 Jan 14 17:43 lockfile.slnx
drwxrwxr-x    4 guitarrapc   guitarrapc      0 Jan 14 17:35 src

./src:
total 12
drwxrwxr-x    4 guitarrapc   guitarrapc      0 Jan 14 17:35 .
drwxrwxr-x    3 guitarrapc   guitarrapc   4096 Jan 14 17:41 ..
drwxrwxr-x    3 guitarrapc   guitarrapc   4096 Jan 14 17:43 ConsoleApp4
drwxrwxr-x    3 guitarrapc   guitarrapc   4096 Jan 14 17:43 ConsoleApp5

./src/ConsoleApp4:
total 20
drwxrwxr-x    3 guitarrapc   guitarrapc   4096 Jan 14 17:43 .
drwxrwxr-x    4 guitarrapc   guitarrapc      0 Jan 14 17:35 ..
-rw-rw-r--    1 guitarrapc   guitarrapc    324 Jan 14 17:36 ConsoleApp4.csproj
-rw-rw-r--    1 guitarrapc   guitarrapc         105 Jan 14 17:35 Program.cs
drwxrwxr-x    2 guitarrapc   guitarrapc   4096 Jan 14 17:43 obj
-rw-rw-r--    1 guitarrapc   guitarrapc     66 Jan 14 17:43 packages.lock.json

./src/ConsoleApp5:
total 20
drwxrwxr-x    3 guitarrapc   guitarrapc   4096 Jan 14 17:43 .
drwxrwxr-x    4 guitarrapc   guitarrapc      0 Jan 14 17:35 ..
-rw-rw-r--    1 guitarrapc   guitarrapc    324 Jan 14 17:36 ConsoleApp5.csproj
-rw-rw-r--    1 guitarrapc   guitarrapc    105 Jan 14 17:36 Program.cs
drwxrwxr-x    2 guitarrapc   guitarrapc   4096 Jan 14 17:43 obj
-rw-rw-r--    1 guitarrapc   guitarrapc     66 Jan 14 17:43 packages.lock.json

$ cat ./src/ConsoleApp4/ConsoleApp4.csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>

    <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="SkiaSharp.QrCode" />
  </ItemGroup>

</Project>

$ cat ./src/ConsoleApp4/packages.lock.json
{
  "version": 2,
  "dependencies": {
    "net10.0": {
      "SkiaSharp.QrCode": {
        "type": "Direct",
        "requested": "[0.12.0, )",
        "resolved": "0.12.0",
        "contentHash": "DTSyBl/rJXcGbSuIzkv20pkTTPUaZbFmouWrOtHG0a2Ide0IsbU9o1mUJb1HsiOgUEK6aAX2+MzP0n7GPssiSA==",
        "dependencies": {
          "SkiaSharp": "3.119.1",
          "SkiaSharp.NativeAssets.Win32": "3.119.1",
          "SkiaSharp.NativeAssets.macOS": "3.119.1"
        }
      },
      "SkiaSharp": {
        "type": "Transitive",
        "resolved": "3.119.1",
        "contentHash": "+Ru1BTSZQne3Vp+vbSb50Ke3Nlc3ZnItxx4+751J9WZ8YzLKAV/n+9DAo4zFTyeCI//ueT63c+VybmTTpYBEiw==",
        "dependencies": {
          "SkiaSharp.NativeAssets.Win32": "3.119.1",
          "SkiaSharp.NativeAssets.macOS": "3.119.1"
        }
      },
      "SkiaSharp.NativeAssets.macOS": {
        "type": "Transitive",
        "resolved": "3.119.1",
        "contentHash": "6hR3BdLhApjDxR1bFrJ7/lMydPfI01s3K+3WjIXFUlfC0MFCFCwRzv+JtzIkW9bDXs7XUVQS+6EVf0uzCasnGQ=="
      },
      "SkiaSharp.NativeAssets.Win32": {
        "type": "Transitive",
        "resolved": "3.119.1",
        "contentHash": "8C4GSXVJqSr0y3Tyyv5jz6MJSTVUyYkMjeKrzK+VyZPGLo89MNoUEclVuYahzOCDdtbfXrd2HtxXfDuvoSXrUw=="
      }
    }
  }
}

```

プロジェクトごとに異なるパッケージを参照することも多いので挙動としては理解できますが、packages.lock.jsonの役割的にはDirectory.Packages.propsのパスに1つだけ生成される方が自然な気はします。

## C#でロックファイルは必要か

### npmとNuGetの文化の違い

ロックファイルが特に有効なのは、パッケージの依存関係がレンジ指定されている場合です。npmでは、`^1.2.3`や`~1.2.3`のようにレンジ指定することが一般的です。このため、ロックファイルを使わないと、同じリポジトリをクローンしても、リストアタイミングで異なるパッケージバージョンがインストールされる可能性を持っています。ロックファイルを使うことで、同じバージョンのパッケージを確実にインストールできます。

一方、NuGetの文化としてレンジ指定することがなく、バージョンが直接指定されます。また、パッケージの競合があった場合、最も低いバージョンを選ぶよう解決されるルールです。このためロックファイルがなくとも、.csprojやDirectory.Packages.propsで直接バージョンが指定されている限りは決定論的(deterministic)にバージョンが決定されます。

C#でバージョン直指定なのはNuGetのUI/UXがそうであることに起因してそうです。`dotnet package add`でパッケージを追加してもバージョンは指定されますし、Visual StudioやRiderのNuGet Package Managerでパッケージを選んだ時もバージョンが指定されます。npmのようにバージョンをレンジ指定/ワイルドカード指定をするには.csprojを直接手で編集する必要があり、ほとんどの人は使いません。Dependabotを使ってもバージョンは直指定されます。NuGetにおいては、レンジ指定を維持するよりバージョン指定することを促す体験で一貫しています。

### SBOMの視点から

SBOMの視点から見ると、ロックファイルpackages.lock.jsonはSource SBOMであって補助的な役割に過ぎません。SBOMにおいて最も重要なのはBuild SBOMであり、C#でもビルド時に`obj/project.assets.json`へ出力します[^2]。

```shell
$ dotnet build -c Release
$ ls -l ./src/ConsoleApp4/obj
total 64
-rw-rw-r--    1 guitarrapc   guitarrapc  22356 Jan 14 17:46 ConsoleApp4.csproj.nuget.dgspec.json
-rw-rw-r--    1 guitarrapc   guitarrapc   1304 Jan 14 17:43 ConsoleApp4.csproj.nuget.g.props
-rw-rw-r--    1 guitarrapc   guitarrapc    150 Jan 14 17:43 ConsoleApp4.csproj.nuget.g.targets
drwxrwxr-x    3 guitarrapc   guitarrapc      0 Jan 14 18:14 Debug
-rw-rw-r--    1 guitarrapc   guitarrapc  28542 Jan 14 17:46 project.assets.json
-rw-rw-r--    1 guitarrapc   guitarrapc    684 Jan 14 17:46 project.nuget.cache
```


## ロックファイルを使っている例

ロックファイルが使われる例もあります。例えば、GitHub ActionsでNuGetのパッケージキャッシュを利用する[actions/cache](https://github.com/actions/cache/blob/main/examples.md?tab=readme-ov-file#c---nuget)がロックファイルを使ったサンプルを提示しています。サンプルは、ロックファイルをキャッシュキーに含めることで、パッケージの変更があった場合のみキャッシュを更新させます。

```yaml
- uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
  with:
    path: ~/.nuget/packages
    key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
    restore-keys: |
      ${{ runner.os }}-nuget-
```

ただ、先にあげたようにCentral Package Managementを使っている場合、プロジェクトごとにロックファイルができます。だったら、バージョンが1.1.1のように指定されているはずなので、`Directory.Packages.props`自体をキャッシュキーに含めたほうがより明示的に更新タイミングが分かるのとキャッシュ効率もほぼ変わらないと嫌いできるので良いでしょう。

```yaml
- uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
  with:
    path: ~/.nuget/packages
    key: ${{ runner.os }}-nuget-${{ hashFiles('Directory.Packages.props') }}
    restore-keys: |
      ${{ runner.os }}-nuget-
```

## まとめ

事前にどのようなパッケージが入るかの予定を示すロックファイルは、C#においてはあまり使われておらず、デフォルトもロックファイルを使う設定じゃないです。いくつかの視点で考えてみましたが、文化的に納得できる部分が大きいです。

## 参考

- [Do you protect your NuGet config against supply chain attacks? | Reddit](https://www.reddit.com/r/dotnet/comments/1duas98/do_you_protect_your_nuget_config_against_supply/)

[^1]: GitHubで[検索すると](https://github.com/search?q=RestorePackagesWithLockFile+language%3AXML&type=code&l=XML&p=1)7300件程度
[^2]: 他のファイルも組み合わせますが、ビルド時に入るファイル一覧として重要
