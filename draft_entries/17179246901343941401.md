---
Title: NuGetのロックファイルは使うべきなのか
Category:
- C#
Date: 2026-01-11T23:00:00+09:00
EditURL: https://blog.hatena.ne.jp/guitarrapc_tech/guitarrapc-tech.hatenablog.com/atom/entry/17179246901343941401
PreviewURL: https://tech.guitarrapc.com/draft/entry/w4e8xX7uO3JSNuAH5FqLdjqQLQY
CustomPath: 2026/01/11/230000
---

NuGetには[ロックファイル](https://devblogs.microsoft.com/dotnet/enable-repeatable-package-restores-using-a-lock-file/)(packages.lock.json)を用いてリストアする機能があります。npmでは`package-lock.json`が当たり前に使われていますが、C#のプロジェクトでロックファイルを使っている例はあまり見かけません。

最近SBOMについて調べる中で、なぜNuGetのロックファイルがあまり使われていないのか、そもそも使うべきなのかを考えてみました。この記事では、NuGetのロックファイルの仕組みと、C#におけるパッケージ管理の文化的な背景から、ロックファイルの必要性について考察します。

[:contents]

## ロックファイルとは

ロックファイルとは、プロジェクトが依存するパッケージのバージョンを固定化するためのファイルです。

[Microsoft Lean](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files)を見ると、プロジェクトが依存するパッケージには、「直接依存するもの(トップレベル・直接/Top-level or Direct)」と「間接的に依存するもの(トランジティブ・推移的/Transitive)」があります。
イメージしやすいようにnpmで例えると、[@modelcontextprotocol/sdk](https://www.npmjs.com/package/%40modelcontextprotocol/sdk)パッケージを入れるとします。
この場合、`@modelcontextprotocol/sdk`が直接依存するパッケージで、`@modelcontextprotocol/sdk`が依存している`@hono/node-server`や`ajv`などは間接的に依存するパッケージです。

[f:id:guitarrapc_tech:20260114182222p:plain:alt=npmで@modelcontextprotocol/sdkの間接的に依存するパッケージが確認できる]<!--image.png-->

ロックファイルは、あるパッケージをインストールしたときのバージョンと、そのパッケージを導入したときに推移的にインストールされたパッケージのバージョンを記録します。これにより、同じプロジェクトを別の環境でセットアップしたときに、同じバージョンのパッケージがインストールされることを保証します。

## NuGetのロックファイル

NuGetにもロックファイルを利用する機能がありますが、デフォルトでは無効になっています。ロックファイルを利用するには`.csproj`で`<RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>`に設定して、プロジェクトをリストア(`dotnet restore`)します。すると、`.csproj`があるパスに`packages.lock.json`というファイルが生成されます。

```xml
  <PropertyGroup>
    <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>
  </PropertyGroup>
```

試してみましょう。プロジェクト追加 → 初回のパッケージ追加 → リストア → ロックファイル追加後のリストアを順に実行します。今回は私の書いているライブラリである[SkiaSharp.QrCode](https://www.nuget.org/packages/SkiaSharp.QrCode)パッケージを使用します。NuGetを見ると`SkiaSharp`や`SkiaSharp.NativeAssets.macOS`/`SkiaSharp.NativeAssets.Win32`に依存していることがわかります。

[f:id:guitarrapc_tech:20260114182231p:plain:alt=NuGetで確認できるSkiaSharp.QrCodeパッケージの依存関係。SkiaSharpやNativeAssetsパッケージに依存していることがわかる]<!--image-1.png-->

では、実際に試してみます。
まずはコンソールプロジェクトを作成し、`SkiaSharp.QrCode`パッケージを追加してリストアします。この時点ではロックファイルは生成されていません。

```shell
$ mkdir -p ConsoleApp3 && cd ConsoleApp3
$ dotnet new console -n ConsoleApp3
$ dotnet package add SkiaSharp.QrCode
$ dotnet restore
Restore complete (0.9s)

Build succeeded in 1.1s

$ ls -la
ls -la
total 16
drwxrwxr-x    3 guitarrapc   guitarrapc      0 Jan 14 16:58 .
drwxrwxr-x    8 guitarrapc   guitarrapc   4096 Jan 14 16:58 ..
-rw-rw-r--    1 guitarrapc   guitarrapc    356 Jan 14 16:59 ConsoleApp3.csproj
-rw-rw-r--    1 guitarrapc   guitarrapc    105 Jan 14 16:58 Program.cs
drwxrwxr-x    2 guitarrapc   guitarrapc   4096 Jan 14 17:00 obj
```

続けて、`<RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>`を追加して再度リストアします。すると、`packages.lock.json`ファイルが生成されます。

```shell
$ cat <<EOF > ConsoleApp3.csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>

    <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="SkiaSharp.QrCode" Version="0.12.0" />
  </ItemGroup>

</Project>
EOF

$ dotnet restore
Restore complete (0.6s)

Build succeeded in 1.1s

$ ls -la
ls -la
total 24
drwxrwxr-x    3 guitarrapc   guitarrapc   4096 Jan 14 17:03 .
drwxrwxr-x    8 guitarrapc   guitarrapc   4096 Jan 14 16:58 ..
-rw-rw-r--    1 guitarrapc   guitarrapc    427 Jan 14 17:03 ConsoleApp3.csproj
-rw-rw-r--    1 guitarrapc   guitarrapc    105 Jan 14 16:58 Program.cs
drwxrwxr-x    2 guitarrapc   guitarrapc   4096 Jan 14 17:03 obj
-rw-rw-r--    1 guitarrapc   guitarrapc   1314 Jan 14 17:03 packages.lock.json  # <- 追加!

$ cat packages.lock.json
{
  "version": 1,
  "dependencies": {
    "net10.0": {
      "SkiaSharp.QrCode": {
        "type": "Direct",
        "requested": "[0.12.0, )",
        "resolved": "0.12.0",
        "contentHash": "DTSyBl/rJXcGbSuIzkv20pkTTPUaZbFmouWrOtHG0a2Ide0IsbU9o1mUJb1HsiOgUEK6aAX2+MzP0n7GPssiSA==",
        "dependencies": {
          "SkiaSharp": "3.119.1",
          "SkiaSharp.NativeAssets.Win32": "3.119.1",
          "SkiaSharp.NativeAssets.macOS": "3.119.1"
        }
      },
      "SkiaSharp": {
        "type": "Transitive",
        "resolved": "3.119.1",
        "contentHash": "+Ru1BTSZQne3Vp+vbSb50Ke3Nlc3ZnItxx4+751J9WZ8YzLKAV/n+9DAo4zFTyeCI//ueT63c+VybmTTpYBEiw==",
        "dependencies": {
          "SkiaSharp.NativeAssets.Win32": "3.119.1",
          "SkiaSharp.NativeAssets.macOS": "3.119.1"
        }
      },
      "SkiaSharp.NativeAssets.macOS": {
        "type": "Transitive",
        "resolved": "3.119.1",
        "contentHash": "6hR3BdLhApjDxR1bFrJ7/lMydPfI01s3K+3WjIXFUlfC0MFCFCwRzv+JtzIkW9bDXs7XUVQS+6EVf0uzCasnGQ=="
      },
      "SkiaSharp.NativeAssets.Win32": {
        "type": "Transitive",
        "resolved": "3.119.1",
        "contentHash": "8C4GSXVJqSr0y3Tyyv5jz6MJSTVUyYkMjeKrzK+VyZPGLo89MNoUEclVuYahzOCDdtbfXrd2HtxXfDuvoSXrUw=="
      }
    }
  }
}
```

ロックファイルの中身を見ると、プロジェクトで直接参照しているパッケージと、間接的に参照しているパッケージが区別されつつ、各パッケージのバージョンが記録されています。

- プロジェクトで直接参照させたパッケージ`SkiaSharp.QrCode`には`"type": "Direct"`が指定され、最新バージョンが利用
- `SkiaSharp.QrCode`ライブラリが依存している`SkiaSharp`や`SkiaSharp.NativeAssets.Win32`などのパッケージには`"type": "Transitive"`が指定

### ロックファイルを使ったリストア

ロックファイルを使用している場合、`dotnet restore`コマンドは`packages.lock.json`ファイルを参照して、NuGetの依存を再評価しつつ指定されたバージョンのパッケージをインストールします。この時パッケージが取得できなかったなど必要があれば、ロックファイルのバージョンは更新されます。不変じゃないのはnpmの`package-lock.json`と同じです。

`npm ci`のように、ロックファイルに記録されたバージョンを厳密に再現する場合、`dotnet restore --locked-mode`コマンドを使うか、`<RestoreLockedMode>true</RestoreLockedMode>`を設定します。npm同様、CIではこのオプションを有効にするのがいいでしょう。

ローカルでは通常の`dotnet restore`を実行し、CIではロックファイルに厳密に従うようにするなら次のように設定します。これにより、異なる環境であっても同じバージョンのパッケージが保証されます。

```xml
  <PropertyGroup>
    <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>
    <RestoreLockedMode Condition="'$(CI)' == 'true'">true</RestoreLockedMode>
  </PropertyGroup>
```

### ロックファイルとCentral Package Managementの組み合わせ

[Central Package Management](https://learn.microsoft.com/ja-jp/nuget/consume-packages/central-package-management)(以降CPM)は、複数プロジェクトのパッケージバージョンを`Directory.Packages.props`で一元管理する機能です。ロックファイルとCPMを組み合わせた場合の動作を確認してみましょう。

ロックファイルはCPMが有効でも特別な対応はしません。つまり、`Directory.Packages.props`でバージョンを一元管理していても、ロックファイルは個々の.csprojパスに生成されます。

試してみましょう。ConsoleApp4とConsoleApp5の2つのプロジェクトを持つソリューションを作成し、`Directory.Packages.props`で`SkiaSharp.QrCode`のバージョンを一元管理します。ロックファイル`packages.lock.json`は`、Directory.Packages.props`のパスではなく各プロジェクトに生成されることを確認します。

まずはルートに`Directory.Build.props`と`Directory.Packages.props`を作成し、ロックファイルとCentral Package Managementを有効にします。

```shell
$ cat <<EOF > Directory.Build.props
<Project>
  <PropertyGroup>
    <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>
    <RestoreLockedMode Condition="'$(CI)' == 'true'">true</RestoreLockedMode>
  </PropertyGroup>
</Project>
EOF

$ cat <<EOF > Directory.Packages.props
<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
    <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
  </PropertyGroup>
  <ItemGroup>
    <PackageVersion Include="SkiaSharp.QrCode" Version="0.12.0" />
  </ItemGroup>
</Project>
EOF
```

続いて、2つのコンソールプロジェクトを作成し、`SkiaSharp.QrCode`パッケージを追加してリストアします。ロックファイルは`Directory.Packages.props`ではなく各プロジェクトに生成されます。[^1]

```shell
$ mkdir -p src/ConsoleApp4 && cd src/ConsoleApp4
$ dotnet new console
$ dotnet package add SkiaSharp.QrCode

$ cd ../../
$ mkdir -p src/ConsoleApp5 && cd src/ConsoleApp5
$ dotnet new console
$ dotnet package add SkiaSharp.QrCode

$ cd ../../
$ dotnet new sln -f slnx
$ dotnet sln add src/ConsoleApp4/ConsoleApp4.csproj
$ dotnet sln add src/ConsoleApp5/ConsoleApp5.csproj
$ dotnet restore
Restore complete (1.4s)

Build succeeded in 1.7s

$ ls -laR
.:
total 20
drwxrwxr-x    3 guitarrapc   guitarrapc   4096 Jan 14 17:41 .
drwxrwxr-x    8 guitarrapc   guitarrapc   4096 Jan 14 16:58 ..
-rw-rw-r--    1 guitarrapc   guitarrapc    210 Jan 14 17:38 Directory.Build.props
-rw-rw-r--    1 guitarrapc   guitarrapc    327 Jan 14 17:39 Directory.Packages.props
-rw-rw-r--    1 guitarrapc   guitarrapc    181 Jan 14 17:43 lockfile.slnx
drwxrwxr-x    4 guitarrapc   guitarrapc      0 Jan 14 17:35 src

./src:
total 12
drwxrwxr-x    4 guitarrapc   guitarrapc      0 Jan 14 17:35 .
drwxrwxr-x    3 guitarrapc   guitarrapc   4096 Jan 14 17:41 ..
drwxrwxr-x    3 guitarrapc   guitarrapc   4096 Jan 14 17:43 ConsoleApp4
drwxrwxr-x    3 guitarrapc   guitarrapc   4096 Jan 14 17:43 ConsoleApp5

./src/ConsoleApp4:
total 20
drwxrwxr-x    3 guitarrapc   guitarrapc   4096 Jan 14 17:43 .
drwxrwxr-x    4 guitarrapc   guitarrapc      0 Jan 14 17:35 ..
-rw-rw-r--    1 guitarrapc   guitarrapc    324 Jan 14 17:36 ConsoleApp4.csproj
-rw-rw-r--    1 guitarrapc   guitarrapc         105 Jan 14 17:35 Program.cs
drwxrwxr-x    2 guitarrapc   guitarrapc   4096 Jan 14 17:43 obj
-rw-rw-r--    1 guitarrapc   guitarrapc     66 Jan 14 17:43 packages.lock.json

./src/ConsoleApp5:
total 20
drwxrwxr-x    3 guitarrapc   guitarrapc   4096 Jan 14 17:43 .
drwxrwxr-x    4 guitarrapc   guitarrapc      0 Jan 14 17:35 ..
-rw-rw-r--    1 guitarrapc   guitarrapc    324 Jan 14 17:36 ConsoleApp5.csproj
-rw-rw-r--    1 guitarrapc   guitarrapc    105 Jan 14 17:36 Program.cs
drwxrwxr-x    2 guitarrapc   guitarrapc   4096 Jan 14 17:43 obj
-rw-rw-r--    1 guitarrapc   guitarrapc     66 Jan 14 17:43 packages.lock.json
```

CPMなので`.csproj`ファイルの中身を見てもパッケージのバージョン指定はありません。

```shell
$ cat ./src/ConsoleApp4/ConsoleApp4.csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="SkiaSharp.QrCode" />
  </ItemGroup>

</Project>

$ cat ./src/ConsoleApp4/packages.lock.json
{
  "version": 2,
  "dependencies": {
    "net10.0": {
      "SkiaSharp.QrCode": {
        "type": "Direct",
        "requested": "[0.12.0, )",
        "resolved": "0.12.0",
        "contentHash": "DTSyBl/rJXcGbSuIzkv20pkTTPUaZbFmouWrOtHG0a2Ide0IsbU9o1mUJb1HsiOgUEK6aAX2+MzP0n7GPssiSA==",
        "dependencies": {
          "SkiaSharp": "3.119.1",
          "SkiaSharp.NativeAssets.Win32": "3.119.1",
          "SkiaSharp.NativeAssets.macOS": "3.119.1"
        }
      },
      "SkiaSharp": {
        "type": "Transitive",
        "resolved": "3.119.1",
        "contentHash": "+Ru1BTSZQne3Vp+vbSb50Ke3Nlc3ZnItxx4+751J9WZ8YzLKAV/n+9DAo4zFTyeCI//ueT63c+VybmTTpYBEiw==",
        "dependencies": {
          "SkiaSharp.NativeAssets.Win32": "3.119.1",
          "SkiaSharp.NativeAssets.macOS": "3.119.1"
        }
      },
      "SkiaSharp.NativeAssets.macOS": {
        "type": "Transitive",
        "resolved": "3.119.1",
        "contentHash": "6hR3BdLhApjDxR1bFrJ7/lMydPfI01s3K+3WjIXFUlfC0MFCFCwRzv+JtzIkW9bDXs7XUVQS+6EVf0uzCasnGQ=="
      },
      "SkiaSharp.NativeAssets.Win32": {
        "type": "Transitive",
        "resolved": "3.119.1",
        "contentHash": "8C4GSXVJqSr0y3Tyyv5jz6MJSTVUyYkMjeKrzK+VyZPGLo89MNoUEclVuYahzOCDdtbfXrd2HtxXfDuvoSXrUw=="
      }
    }
  }
}
```

プロジェクトごとに異なるパッケージを参照することも多いので挙動としては理解できますが、packages.lock.jsonの役割的にはDirectory.Packages.propsのパスに1つだけ生成される方が自然な気はします。ただ、`.csproj`でパッケージをオーバーライドする場合もあるので、今の設計のままになりそうです。

## ロックファイルを使っている例

個人的にはロックファイルは使いませんが、ロックファイルが使われる例もあります。例えば、GitHub ActionsでNuGetのパッケージキャッシュを利用する[actions/cache](https://github.com/actions/cache/blob/main/examples.md?tab=readme-ov-file#c---nuget)がロックファイルを使ったサンプルを提示しています。サンプルは、ロックファイルをキャッシュキーに含めることで、パッケージの変更があった場合のみキャッシュを更新させます。

```yaml
- uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
  with:
    path: ~/.nuget/packages
    key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
    restore-keys: |
      ${{ runner.os }}-nuget-
```

ただ、先にあげたようにCentral Package Managementを使っている場合、プロジェクトごとにロックファイルができます。だったら、バージョンが1.1.1のように指定されているはずなので、`Directory.Packages.props`自体をキャッシュキーに含めたほうがより明示的に更新タイミングが分かるのとキャッシュ効率もほぼ変わらないと予測できます。

```yaml
- uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
  with:
    path: ~/.nuget/packages
    key: ${{ runner.os }}-nuget-${{ hashFiles('Directory.Packages.props') }}
    restore-keys: |
      ${{ runner.os }}-nuget-
```

実際にロックファイルをキャッシュキーにしている[記事](https://blog.shibayan.jp/entry/20210118/1610949669)を見ても、キャッシュによる効果はあまり感じられなかったと書かれています。プロジェクトで利用しているパッケージのボリュームによりますが、GitHub Actionsのキャッシュリストアは早くないのでキャッシュヒット率が上がっても劇的に早くなるわけではないのは納得感があります。

## C#でロックファイルは必要か

本題です。C#でロックファイルは必要なのでしょうか？ 個人的にはロックファイルはあまり必要ないと考えています。それは、C#はNuGetのパッケージをバージョン直指定する文化があり、推移的パッケージの解決も競合した場合最も低いバージョンを選ぶルールで、決定論的にバージョンが決定されるからです。

実際、GitHubでRestorePackagesWithLockFileをキーに[検索すると](https://github.com/search?q=RestorePackagesWithLockFile+language%3AXML&type=code&l=XML&p=1)7300件程度と、C#リポジトリ全体が6.9M件あることからすると少ないです。このことから、C#のプロジェクトでロックファイルを使う文化があまり根付いていないことがわかります。

### npmとNuGetの文化の違い

ロックファイルが特に有効なのは、パッケージの依存関係がレンジ指定されている場合です。npmでは、`^1.2.3`や`~1.2.3`のようにレンジ指定することが一般的です。このため、ロックファイルを使わないと、同じリポジトリをクローンしても、リストアタイミングで異なるパッケージバージョンがインストールされる可能性を持っています。ロックファイルを使うことで、同じバージョンのパッケージを確実にインストールできます。

一方、NuGetの文化としてレンジ指定することがなく、バージョンが直接指定されます。また、パッケージの競合があった場合、最も低いバージョンを選ぶよう解決されるルールです。このためロックファイルがなくとも、.csprojやDirectory.Packages.propsで直接バージョンが指定されている限りは決定論的(deterministic)にバージョンが決定されます。

C#でバージョン直指定なのはNuGetのUI/UXがそうであることに起因してそうです。

例えば、`dotnet package add`でパッケージを追加してもバージョンは指定されます。

```shell
# バージョン指定を省略した場合、自動的に最新バージョンが指定される
$ dotnet package add SkiaSharp.QrCode

# バージョンを指定することも可能だが、最新バージョンを指定するなら不要
$ dotnet package add SkiaSharp.QrCode --version 0.12.0
```

Visual StudioやRiderのNuGet Package Managerでパッケージをインストール・アップグレードする際もバージョンを指定するようになっており、レンジ指定をサポートしていません。

[f:id:guitarrapc_tech:20260115014836p:plain:alt=Visual StudioのManage NuGet Packageでもバージョンを指定する]<!--image-2.png-->

npmのようにバージョンを[レンジ/ワイルドカード指定](https://learn.microsoft.com/en-us/nuget/concepts/package-versioning?tabs=semver20sort)をするには.csprojを直接手で編集する必要があり、ほとんどの人は使いません。

[f:id:guitarrapc_tech:20260115014843p:plain:alt=直接.csprojの編集が必要]<!--image-3.png-->

レンジ指定していても、Dependabotで自動更新させるとバージョンは直指定されます。

NuGetにおいては、レンジ指定を維持するよりバージョン指定することを促す体験で一貫しています。

### SBOMの視点から

SBOMの視点から見ると、ロックファイルpackages.lock.jsonはSource SBOMであって補助的な役割に過ぎません。SBOMにおいて最も重要なのはBuild SBOMであり、C#でもビルド時に`obj/project.assets.json`へ出力します。

```shell
$ dotnet build -c Release
$ ls -l ./src/ConsoleApp4/obj
total 64
-rw-rw-r--    1 guitarrapc   guitarrapc  22356 Jan 14 17:46 ConsoleApp4.csproj.nuget.dgspec.json
-rw-rw-r--    1 guitarrapc   guitarrapc   1304 Jan 14 17:43 ConsoleApp4.csproj.nuget.g.props
-rw-rw-r--    1 guitarrapc   guitarrapc    150 Jan 14 17:43 ConsoleApp4.csproj.nuget.g.targets
drwxrwxr-x    3 guitarrapc   guitarrapc      0 Jan 14 18:14 Debug
-rw-rw-r--    1 guitarrapc   guitarrapc  28542 Jan 14 17:46 project.assets.json
-rw-rw-r--    1 guitarrapc   guitarrapc    684 Jan 14 17:46 project.nuget.cache
```

`project.assets.json`ファイルには、ビルドに使用されるすべてのパッケージとそのバージョンが含まれています。これにより、SBOMを生成する際により正確な依存関係情報を取得できます[^2]。実際、SBOMツールの[synk](https://docs.snyk.io/developer-tools/snyk-cli/commands/sbom)や[CycloneDX](https://github.com/CycloneDX/cyclonedx-dotnet/blob/0ae5d6a8a8c4d30266044d113da6eb6fa16a8e1c/CycloneDX/Services/ProjectFileService.cs#L233)はNuGetに対しては`project.assets.json`を参照しています。

## まとめ

C#においてロックファイルはデフォルトで無効になっており、実際に使われている例もあまり見かけません。パッケージをバージョン直指定する文化と、決定論的なバージョン解決の仕組みにより、ロックファイルを使うメリットは小さいと考えています。

ただし、以下のようなケースでは検討の余地があります。

- 推移的な依存関係の変更を厳密に追跡したいケース
- CIでのキャッシュ戦略として活用する場合（ただし、Central Package Management使用時は`Directory.Packages.props`で十分）

今後ソフトウェアサプライチェーンのセキュリティがより重要になる中で、ロックファイルの役割も見直される可能性はあります。しかし現時点では、C#のエコシステムにおいて決定論的な保証ができないケースが思いつかず、必須とは言えない状況です。

## 参考

ドキュメント

- [Enable repeatable package restores using a lock file | .NET Blog](https://devblogs.microsoft.com/dotnet/enable-repeatable-package-restores-using-a-lock-file/)
- [NuGet PackageReference in project files | Microsoft Learn](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files)
- [Do you protect your NuGet config against supply chain attacks? | Reddit](https://www.reddit.com/r/dotnet/comments/1duas98/do_you_protect_your_nuget_config_against_supply/)
- [Central Package Management | Microsoft Learn](https://learn.microsoft.com/en-us/nuget/consume-packages/central-package-management)
- [NuGet Package Version Reference | Microsoft Learn](https://learn.microsoft.com/en-us/nuget/concepts/package-versioning?tabs=semver20sort)
- [SBOM | Snyk User Docs](https://docs.snyk.io/developer-tools/snyk-cli/commands/sbom)

ブログ

- [NuGet のロックファイルと CI でのパッケージキャッシュ - しばやん雑記](https://blog.shibayan.jp/entry/20210118/1610949669)

GitHub

- [cache/examples.md - actions/cache | GitHub](https://github.com/actions/cache/blob/main/examples.md?tab=readme-ov-file#c---nuget)
- [CycloneDX/cyclonedx-dotnet | GitHub](https://github.com/CycloneDX/cyclonedx-dotnet)


[^1]: .NET SDK 10.0.102以降で`dotnet new sln -f slnx`が利用可能です
[^2]: 他のファイルも組み合わせますが、ビルド時に入るファイル一覧として重要
